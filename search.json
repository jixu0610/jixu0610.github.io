[{"title":"vue-element-admin之增删改查","url":"/2025/04/20/vue-element-admin%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","content":"介绍： 是一个后台前端解决方案，它基于 vue 和 element-ui实现。它使用了最新的前端技术栈，内置了 i18 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型\n\n\n\n\n下面就以用户管理为例来讲讲增删改查吧数据库结构：\n\n\n\n\n\n\n页面成品：\n\n\n\n\n概述： 总结常见的增删改查细节： \n（1） element-ui 数据呈现的形式\n（2） 相关函数的调用细节\n\n\n\n查询：比较常规，查询表单绑定提交的查询数据模型，点击按钮触发提交方法，方法调用@&#x2F;api中的方法调用后端接口，返回数据，表格绑定指定数据并通过数据的属性一一呈现。\n\n\n值得一提的是以下三种情况：\n\n\n(1) 后台返回部门树形结构数据并通过前端呈现，其中涉及到 递归 的使用：\n\n\n\n后端：\n   public static List&lt;Dept&gt; buildTree(List&lt;Dept&gt; deptList, int pid) &#123;           // 0；父节点 其他：子节点           List&lt;Dept&gt; deptTree = new ArrayList&lt;&gt;();           Optional.ofNullable(deptList).orElse(new ArrayList&lt;&gt;())                   .stream().filter(dept -&gt; dept!=null &amp;&amp; dept.getPid()==pid)                   .forEach(dept -&gt; &#123;                       Dept dept1 = new Dept();                       BeanUtils.copyProperties(dept, dept1);                       dept1.setChildren(buildTree(deptList, dept.getId()));                       deptTree.add(dept1);                   &#125;);           return deptTree;       &#125;      // 查询所有的dept表数据 List&lt;Dept&gt; deptList，再添加顶部数据：   Dept dept = new Dept();   dept.setDeptName(&quot;所有部门&quot;).setId(0).setPid(-1);   deptList.add(dept);   // 构造树形数据结构return DeptTreeUtils.buildTree(deptList, -1);\n\n\n\n前端：\n   &lt;el-tree :data=&quot;treeData&quot; :props=&quot;defaultProps&quot; node-key=&quot;id&quot; :default-expand-all=&quot;true&quot; empty-text=&quot;暂无数据&quot; @node-click=&quot;handleNodeClick&quot; :highlight-current=&quot;true&quot;&gt;&lt;/el-tree&gt;      &lt;!--   props: 呈现的属性   node-key 的作用：只是告诉组件用哪个字段作为节点的唯一标识（类似主键），用于组件内部管理节点状态（如展开、选中、查找等）。   handleNodeClick 的作用：点击节点时，它会传递完整的节点数据对象给你   其他： 默认展开， 校验， 点击事件， 选中高亮显示   --&gt;      handleNodeClick(data) &#123;    this.userModel.deptId = data.id;       this.search();&#125;,\n\n好的，如此便可呈现树形结构数据了，点击既可将dept_id赋值给userModel的deptId属性，实现查询功能。\n\n\n此时，便有一个问题了，点击顶级菜单”所有部门”为什么会发生查询所有用户？这就需要向内看看查询的逻辑了：\n逻辑很寻常，我设置的所有用户的dept_id都为空，读取mysql数据库的dept_id列时，ResultSet.getInt()会返回0，而顶级菜单的id即为0，所以查询全部用户。😂\n\n\n\n\n(2) 复选框\n\n\n\n相对来讲比较简单: 就是点击按钮向后端请求所有选项数据roleList，呈现的属性是roleName, 值（label）为id，默认选项为el-checkbox-group标签的绑定模型roleIds内的元素，点选复选框，可改变roleIds内的元素，以下为前端标签结构：\n\n\n&lt;el-dialog title=&quot;角色绑定&quot; :visible.sync=&quot;dialogRoleVisible&quot; width=&quot;30%&quot;&gt;    &lt;el-checkbox-group v-model=&quot;roleIds&quot;&gt;        &lt;el-checkbox v-for=&quot;item in roleList&quot; :key=&quot;item.id&quot; :label=&quot;item.id&quot;&gt;&#123;&#123;item.roleName&#125;&#125;&lt;/el-checkbox&gt;    &lt;/el-checkbox-group&gt;    &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;        &lt;el-button @click=&quot;clearBind&quot;&gt;取消&lt;/el-button&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;handleBindRole&quot;&gt;确定&lt;/el-button&gt;    &lt;/div&gt;&lt;/el-dialog&gt;\n\n\n\n处理逻辑： 点击角色绑定按钮，向后台发送2个请求 ：（1）所有的角色数据  （2）与用户联系的角色id\n点选复选框之后，发送请求携带userId和roleList，后台先删除userId相关联的roleId, 在批量插入用户角色关系。😁\n\n\n\n\n（3）分页查找的逻辑\n\n单表分页查询的情况下，可以直接使用baseMapper.selectByPage(page, 查询对象)\n\n\n多表联合查询的情况下:\n使用：baseMapper.searchByPage(page, autoInfo);AutoInfoMapper中定义searchByPage方法Page&lt;AutoInfo&gt; searchByPage(Page&lt;AutoInfo&gt; page, AutoInfo autoInfo);Mapper.xml中：AutoInfo.xml：&lt;select id=&quot;searchByPage&quot; resultType=&quot;com.coder.rental.entity.AutoInfo&quot;&gt;    select i.*, m.name, b.brand_name     from auto_info i, auto_maker m, auto_brand b\twhere i.maker_id = m.id and i.brand_id = b.id 后续为对象条件查询&lt;/select&gt;\n\n值得注意的是，这里传入的page对象好像在查询中用不到，应该在返回中使List&lt;.AutoInfo.&gt;自动转化成Page对象吧，挺邪乎的😒\n\n\n\n\n（4）根据身份证号确定出生日期,性别和年龄\n\n&lt;el-form-item label=&quot;身份证号&quot; prop=&quot;idNum&quot;&gt;    &lt;el-input v-model=&quot;saveCustomer.idNum&quot; @change=&quot;setCustomerInfo&quot;&gt;&lt;/el-input&gt;&lt;/el-form-item&gt;               &lt;el-form-item label=&quot;客户年龄&quot; prop=&quot;age&quot;&gt;    &lt;el-input v-model=&quot;saveCustomer.age&quot; :readonly=&quot;true&quot;&gt;&lt;/el-input&gt;&lt;/el-form-item&gt;&lt;el-form-item label=&quot;客户性别&quot; prop=&quot;gender&quot;&gt;    &lt;el-radio-group v-model=&quot;saveCustomer.gender&quot;&gt;        &lt;el-radio-button :label=&quot;1&quot; disabled&gt;男&lt;/el-radio-button&gt;        &lt;el-radio-button :label=&quot;0&quot; disabled&gt;女&lt;/el-radio-button&gt;    &lt;/el-radio-group&gt;&lt;/el-form-item&gt;&lt;el-form-item label=&quot;出生日期&quot; prop=&quot;birthday&quot;&gt;    &lt;el-date-picker v-model=&quot;saveCustomer.birthday&quot;                    type=&quot;date&quot; placeholder=&quot;选择日期&quot;                    value-format=&quot;yyyy-MM-dd&quot; :readonly=&quot;true&quot;&gt;    &lt;/el-date-picker&gt;&lt;/el-form-item&gt;&lt;script&gt;    setCustomerInfo(val) &#123;        //220202199911312661        //处理性别        const sex = val.charAt(val.length - 2)        this.saveCustomer.gender = sex % 2        //获取用户身份证上的出生日期        const birthday = val.substring(6, 14)        //当前系统时间        const now = new Date()        const birthDate = new Date(birthday.substring(0, 4), birthday.substring(4, 6) - 1, birthday.substring(6, 8))        let timeDiff = Math.abs(now.getTime() - birthDate.getTime())        if (timeDiff &gt; 0) &#123;            //计算年龄            this.saveCustomer.age = Math.floor(timeDiff / (1000 * 60 * 60 * 24 * 365))            //计算出生日期            this.saveCustomer.birthday = birthDate//birthday.substring(0,4)+&quot;-&quot;+birthday.substring(4,6)+&quot;-&quot;+birthday.substring(6,8)        &#125;        this.$forceUpdate()    &#125;&lt;/script&gt;\n\n\n\n\n\n(5) 日期选择&lt;el-form-item&gt;    &lt;el-date-picker v-                    model=&quot;violationModel.violationTimeVal&quot; type=&quot;datetimerange&quot;                    value-format=&quot;yyyy-MM-dd HH:mm:ss&quot; :picker-                    options=&quot;pickerOptions&quot; range-separator=&quot;至&quot;                    start-placeholder=&quot;开始日期&quot; end-placeholder=&quot;结束日期&quot;                    align=&quot;right&quot;&gt;    &lt;/el-date-picker&gt;&lt;/el-form-item&gt;&lt;el-form-item label=&quot;违章时间&quot; prop=&quot;vtime&quot;&gt;    &lt;el-date-picker v-model=&quot;saveViolation.vtime&quot;                    type=&quot;datetime&quot; placeholder=&quot;选择日期&quot;                    value-format=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;&lt;/el-form-item&gt;&lt;!--后端实体类数据：@ApiModelProperty(&quot;违章时间&quot;)@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)private LocalDateTime vtime;--&gt;\n\n\n\n\n\n(6) 下拉框车辆保养的新增选择车牌，车辆信息新增所属厂商，汽车出租\n\n\n\n\n(7) 侧边栏\n添加和修改：弹出添加修改对话框，注意延迟校验，表单绑定保存数据模型saveUser，此时有寻常编辑的情况，有点击弹出树形结构，进行点选的情况（上面查询时已经介绍过了）， 这里重点介绍上传头像的情况：\n\n对，我们用到的就是aliyun的oss服务，详细的上传和删除请参考阿里云上传和删除图片，我们这里只谈一谈增添头像的逻辑：\n点击上传图片，后端返回图片地址，前端利用地址显示图片即可\n所以这里只讨论前端：\n&lt;el-form-item label=&quot;用户头像&quot; prop=&quot;avatar&quot;&gt;    &lt;el-upload               class=&quot;avatar-uploader&quot;               :action=&quot;uploadPath&quot;               :show-file-list=&quot;false&quot;               :on-success=&quot;handleAvatarSuccess&quot;               :before-upload=&quot;beforeAvatarUpload&quot;               :data=&quot;uploadToken&quot;&gt;        &lt;img v-if=&quot;saveUser.avatar&quot; :src=&quot;saveUser.avatar&quot; class=&quot;avatar&quot; width=&quot;80&quot;&gt;        &lt;i v-else class=&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;/i&gt;    &lt;/el-upload&gt;&lt;/el-form-item&gt;&lt;script&gt;export default &#123;    data() &#123;        return &#123;            uploadPath: process.env.VUE_APP_BASE_API + &#x27;rental/oss/upload&#x27;,            uploadToken: &#123;token: getToken()&#125;,        &#125;    &#125;,        methods: &#123;        handleAvatarSuccess(res, file) &#123;            this.saveUser.avatar = res.data;            this.$forceUpdate();        &#125;,        beforeAvatarUpload(file) &#123;            // 上传头像之前的验证            const isJPG = file.type === &#x27;image/jpeg&#x27; || file.type === &#x27;image/png&#x27;;            const isLt2M = file.size/1024/1024 &lt; 2;            if (!isJPG) &#123;                this.$message.error(&#x27;上传头像只能是 JPG 或 PNG 格式！&#x27;);            &#125;            if (!isLt2M) &#123;                this.$message.error(&#x27;上传头像大小不能超过2MB!&#x27;);            &#125;            return isJPG &amp;&amp; isLt2M;        &#125;,    &#125;&#125;&lt;/script&gt;\n\nok，正如上所示，有上传地址，携带token令牌，上传之前进行验证，上传成功后图片地址赋值给saveUser.avatar\n\n\n这里有一个问题：\n以下两个语句的引用逻辑：\nimport &#123; getToken &#125; from &#x27;@/utils/auth&#x27;;// VUE_APP_BASE_API 定义在 @/env.development文件下（）, 可以直接通过process引用uploadPath: process.env.VUE_APP_BASE_API + &#x27;rental/oss/upload&#x27;, // getToken() 定义在@/utils/auth中uploadToken: &#123;token: getToken()&#125;,    // 好的，我们来看一下token的获取过程：就是封装的Cookies中获取// @/utils/auth.js: import Cookies from &#x27;js-cookie&#x27;const TokenKey = &#x27;Admin-Token&#x27;export function getToken() &#123;  return Cookies.get(TokenKey)&#125;\n\n\n\n\n删除\n\n这里的删除可以是指定行的元素删除，也可以是选中数行进行批量删除\n\n\n指定行的删除： 卡槽获取对象，将对象传入删除函数根据id进行删除\n批量删除： 利用 el-table-column type&#x3D;”selection” 构建基本复选框，点击时触发 el-table @selection-change事件\n下面来详细看看批量删除的元素勾选：\n&lt;script&gt;export default &#123;    data() &#123;        return &#123;            multipleSelection: [],  // 获取删除的批量id        &#125;    &#125;,        methods: &#123;         handleSelectionChange(val) &#123;            this.multipleSelection = [];            val.forEach(element =&gt; &#123;            this.multipleSelection.push(element.id);            &#125;);        &#125;,    &#125;&#125;&lt;/script&gt;\n\n每次点击的时候要清除multipleSelection\n\n\nok了，一些常见的增删改查操作已经总结完毕，如果后续出现新的情况，会进行补充的🎃\n","categories":["vue","vue-element-admin","java项目","汽车租赁管理系统"],"tags":["vue","vue-element-admin"]},{"title":"GitHub Page + Hexo 创建个人博客","url":"/2025/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"介绍： 编写md格式文件，使用 Hexo 渲染成静态网页文件，用git上传至github仓库（仓库名即用户名），可由 仓库名.github.io 地址访问。\n\n\n一. 初次使用：\n环境准备：\ngit\nnode（版本14.0.0+）\n\n\nHexo安装：\nnpm install -g hexo-cli\n\n\n\n初始化框架, 创建工作文件夹test:\nnpm init test;npm install; // 安装框架所需\n\n\n\n生成静态网页\nhexo g\n\n\n\n\n启动服务\nhexo s\n\n\n\n​\t访问 127.0.0.1:4000 查看页面效果。\n\n\n\n\n二. Next主题:\n下载next主题：\ncd testgit clone https://github.com/iissnan/hexo-theme-next themes/next\n\n\n\n_config.yml 文件找到 theme, 更改：\ntheme: next\n\n\n\n选择主题形式： 在&#x2F;theme&#x2F;next&#x2F;_config.yml找到 scheme\n# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini  # 推荐\n\n\n\n设置语言：在_config.yml中找到 language， 设置：\nlanguage: zh-Hans # 默认en\n\n\n\n设置菜单： 在&#x2F;theme&#x2F;next&#x2F;_config.yml找到 menu\nmenu:  home: /              # 首页  archives: /archives  # 归档  #about: /about  #categories: /categories  #tags: /tags  #commonweal: /404.html\n\n\n\n\n\n\n若你的站点运行在子目录中，请将链接前缀的 &#x2F; 去掉\n\n\n\n\n\n\n三. 修改个人信息\n编辑_config.yml， 设置author，title,  subtitle, description等:\n# Sitetitle: yourTitle   #标题subtitle: &#x27;&#x27;       #副标题description: &#x27;&#x27;keywords:author: you        #作者language: zh-Hans  #语言timezone: &#x27;Asia/Shanghai&#x27; #时区\n\n\n\n设置头像： 在source文件夹下创建 image文件夹，放置图片\navatar: /images/博客头像.png  # /images/图片.png   图片的格式 \n\n\n\n\n\n四. 编写文章编写md格式文章，放在 source&#x2F;_posts 文件夹下\nhexo new &quot;post title&quot; # 创建文章，默认md格式host g  # 全部原文章渲染到public静态目录\n\n\n\n\n\n五. 上传至github\n安装一键部署插件：\nnpm install hexo-deployer-git --save\n\n\n\n_config.yml中添加部署配置：\ndeploy:  type: git  repo: git@github.com:&lt;username&gt;/&lt;project&gt;  #example,https://github.com/hexojs/hexojs.github.io  branch: master  # 上传github仓库分支，可更改\n\n\n\n上传：\nhexo d\n\n\n\n访问地址：yourUserName.github.io  (注意你上传的仓库名和你的github的用户名必须相同！)\n\n\n\n\n恭喜你已经创建了属于你的博客。\n","categories":["hexo"],"tags":["创建博客","hexo"]},{"title":"阿里云OSS","url":"/2025/04/20/%E9%98%BF%E9%87%8C%E4%BA%91OSS/","content":"介绍： 有时，我们将图片等静态资源存储在服务器上，但当图片多时，网站加载图片等静态资源的时间会变长，服务体检就会打折扣，这时我们就可以借助阿里云等云服务的对象存储服务直接上传图片，在网站html页面引用图片地址即可。\n\n\n\n\nspringboot如何介入aliyun OSS服务呢?  那么现在开始吧\n\n\n\n首先是在 springboot 配置文件 application.yml 中加入以下:\naliyun:  oss:    endpoint:    access-key-id:    access-key-secret:    bucket-name:\n\n需要注册阿里云的OSS服务才可以有bucket-name和endpoint, 身份认证的两个属性：access-key-id 和 access-key-secret\n\n\n\n\n再把它封装成一个对象OSSConfig, 方便操作👍\nimport lombok.Data;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component@Datapublic class OSSConfig &#123;    @Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)    private String endpoint;    @Value(&quot;$&#123;aliyun.oss.access-key-id&#125;&quot;)    private String accessKeyId;    @Value(&quot;$&#123;aliyun.oss.access-key-secret&#125;&quot;)    private String accessKeySecret;    @Value(&quot;$&#123;aliyun.oss.bucket-name&#125;&quot;)    private String bucketName;&#125;\n\n\n\n\n\n再就是创建一个接口及其实现类，完成图片的上传和删除逻辑：\n// 先创建IOssService，定义上传和删除方法import cn.hutool.core.util.StrUtil;import com.aliyun.oss.OSS;import com.aliyun.oss.OSSClientBuilder;import com.coder.rental.config.OSSConfig;import com.coder.rental.service.IOssService;import com.coder.rental.utils.FileUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;@Servicepublic class OssServiceImpl implements IOssService &#123;    @Autowired    private OSSConfig ossConfig;    public String upload(MultipartFile file) &#123;        String originalFilename = file.getOriginalFilename();        String fileName = FileUtils.getFileName(originalFilename);        OSS ossClient = new OSSClientBuilder().build(                ossConfig.getEndpoint(),                ossConfig.getAccessKeyId(),                ossConfig.getAccessKeySecret()        );        try &#123;            // 完成上传处理            ossClient.putObject(ossConfig.getBucketName(), fileName, file.getInputStream());            return &quot;https://&quot; + ossConfig.getBucketName() + &quot;.&quot; +  ossConfig.getEndpoint() + &quot;/&quot; + fileName;        &#125; catch (Exception e) &#123;            throw new RuntimeException(&quot;上传文件失败&quot;);        &#125; finally &#123;            if (ossClient != null) &#123;                ossClient.shutdown();            &#125;        &#125;    &#125;    @Override    public boolean delete(String url) &#123;        OSS ossClient = new OSSClientBuilder().build(                ossConfig.getEndpoint(),                ossConfig.getAccessKeyId(),                ossConfig.getAccessKeySecret()        );        String host = &quot;https://&quot; + ossConfig.getBucketName() + &quot;.&quot; + ossConfig.getEndpoint() + &quot;/&quot;;        String objectName = StrUtil.removePrefix(url, host);        try &#123;            ossClient.deleteObject(ossConfig.getBucketName(), objectName);            return true;        &#125; catch (Exception e) &#123;            throw new RuntimeException(&quot;删除失败&quot;);        &#125; finally &#123;            if (ossClient != null) &#123;                ossClient.shutdown();            &#125;        &#125;    &#125;&#125;\n\n\n\n\n\n最后就是 controller 层的调用了\n\n\n\n\n就是这么简单\n\n\n","categories":["云服务","阿里云OSS"],"tags":["阿里云OSS"]},{"title":"vue-element-admin初始搭建","url":"/2025/04/23/vue-element-admin%E5%88%9D%E5%A7%8B%E4%BD%BF%E7%94%A8/","content":"介绍： 初始搭建是在后端的访问权限模块完成之后进行的，主要内容为登录退出，菜单路由导航这两部分，构建一个大体框架，之后内容的编写就只需注重内容本身即可。\n\n\n一. vue-element-admin安装\n\n\n\n二.后端\n用户登录获取该用户信息(id, 用户名, 头像, 角色名称数组)\n@GetMapping(&quot;/getInfo&quot;)public Result getUserInfo() &#123;    // 从securityContextHolder上下文中获取认证信息    Authentication authentication =        SecurityContextHolder.getContext().getAuthentication();    if (authentication == null) &#123;        return Result.fail().setMessage(&quot;认证信息为空&quot;);    &#125;    User user = (User) authentication.getPrincipal();    // 查询用户角色名称    /*List&lt;String&gt; list = userService.selectRoleName(user.getId());       Object[] array = list.toArray(); */// 将角色名称列表转换为数组    List&lt;Permission&gt; permissionList = user.getPermissionList();    Object[] array = permissionList.stream().filter(Objects::nonNull)        .map(Permission::getPermissionCode)        .toArray();    // 创建并填充用户信息视图对象    UserInfoVo userInfoVo = new UserInfoVo(user.getId(),                                           user.getUsername(),                                           user.getAvatar(), user.getNickname(), array);    return Result.success(userInfoVo).setMessage(&quot;获取用户信息成功&quot;);&#125;\n\n注意角色数组要用 Permission 中的 permissionCode\n\n\n参照router-&gt;index.js中的路由选项，编写routerVO\n&#123;    path: &#x27;/error&#x27;,    component: Layout,    redirect: &#x27;noRedirect&#x27;,    name: &#x27;ErrorPages&#x27;,    meta: &#123;      title: &#x27;Error Pages&#x27;,      icon: &#x27;404&#x27;,      roles: [&#x27;admin&#x27;, &#x27;editor&#x27;]    &#125;,    children: [      &#123;        path: &#x27;401&#x27;,        component: () =&gt; import(&#x27;@/views/error-page/401&#x27;),        name: &#x27;Page401&#x27;,        meta: &#123; title: &#x27;401&#x27;, noCache: true &#125;      &#125;,      &#123;        path: &#x27;404&#x27;,        component: () =&gt; import(&#x27;@/views/error-page/404&#x27;),        name: &#x27;Page404&#x27;,        meta: &#123; title: &#x27;404&#x27;, noCache: true &#125;      &#125;    ]&#125;\n\n\n\n@Data@JsonInclude(JsonInclude.Include.NON_EMPTY) // 注意加上该注解，不序列化空childrenpublic class RouteVO &#123;    private String path;    private String component;    private String name;    private Boolean alwaysShow;    private Meta meta;    private List&lt;RouteVO&gt; children;    @Data    @NoArgsConstructor    @AllArgsConstructor    public class Meta &#123;        private String title;        private String icon;        private String[] roles;    &#125;&#125;\n\n\n\n根据权限列表，经过路由菜单工具类获取路由信息\n@GetMapping(&quot;/menuList&quot;)public Result getMenuList() &#123;    //获取当前用户信息    Authentication authentication =        SecurityContextHolder.getContext().getAuthentication();    if (authentication == null) &#123;        return Result.fail().setMessage(&quot;认证信息为空&quot;);    &#125;    User user = (User) authentication.getPrincipal();    //获取用户的权限列表    List&lt;Permission&gt; permissionList = user.getPermissionList();    //获取用户的菜单    //将permission_type为2的按钮移除，不需要生成对应的菜单    permissionList.removeIf(permission -&gt;                            Objects.equals(permission.getPermissionType(), 2));    List&lt;RouteVO&gt; routeVOList =        RouteTreeUtils.buildRouteTree(permissionList, 0);    return Result.success(routeVOList).setMessage(&quot;获取菜单列表成功&quot;);&#125;\n\n\n\n退出登录接口\n@PostMapping(&quot;/logout&quot;)public Result logout(HttpServletRequest request, HttpServletResponse                     response)&#123;    String token=request.getHeader(&quot;token&quot;);    if (StrUtil.isEmpty(token))&#123;        token=request.getParameter(&quot;token&quot;);    &#125;    Authentication authentication =        SecurityContextHolder.getContext().getAuthentication();    if (authentication!=null)&#123;        //用户一旦登出系统，则清除redis中的token        redisUtils.del(&quot;token:&quot;+token);        SecurityContextLogoutHandler handler = new            SecurityContextLogoutHandler();        handler.logout(request,response,authentication);        return Result.success().setMessage(&quot;登出成功&quot;);    &#125;    return Result.fail().setMessage(&quot;登出失败&quot;);&#125;\n\n\n\n这个时候后端就完成了，总结以下后端完成内容吧🎃：\n（1）获取用户信息  （2）获取路由信息   （3）退出登录\n\n\n\n\n\n\n三.前端之登录退出\n\n\n好的，我们现在开始前端部分，首先是前端登录：先稍微修改一下前端页面😁，然后就有一个问题了，怎么让前端发送登录请求到后端呢？我们来解决：\n\n\n\n（1）先修改以下开发环境**.env.development和生产环境.env.production**的文件：\nVUE_APP_BASE_API = &#x27;http://localhost:8888/&#x27;\n\n\n\n（2） 然后修改发送请求的文件request.js:\n\n\n​\t安装qs依赖，实现参数序列化处理：\nnpm install qs\n\n\n\n​\t修改service，用 process.env.VUE_APP_BASE_API 来表示要发送的服务器及其端口\n// create an axios instanceconst service = axios.create(&#123;    baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url    // withCredentials: true, // send cookies when cross-domain requests    timeout: 5000 // request timeout&#125;)// 接下来就是request拦截, 在Header中放置token// response拦截，判断响应code来做处理// 定义requestHttp,用于发送请求：get, post, put, delete, upload, login// 下面以post为例：post(url,params) &#123;    return service.post(        url, params, &#123;            transformRequest: [(params) =&gt; &#123;                return JSON.stringify(params)            &#125;],            headers: &#123;                &#x27;Content-Type&#x27;: &#x27;application/json&#x27;            &#125;        &#125;,    )&#125;// service的post方法发送的url参数和自身定义时的baseUrl相结合。\n\n\n\n好的，我们来总结一下发送请求的问题吧，发送请求的方式是Axios，定义service时设置baseURL为服务器及其端口，后续调用service方法请求时，传入请求路径（在baseURL的基础上）和参数即可。\n\n\n（3）我们搞清楚请求路径之后就可以在api&#x2F;user.js中定义请求方法用于获取用户信息和路由信息了\n\n\n（4） 登录的最后部分，还有一些小细节需要修改╰(°▽°)╯： 返回的token需要存储呀：\nimport &#123; getToken, setToken, removeToken &#125; from &#x27;@/utils/auth&#x27;const state = &#123;  token: getToken(),  name: &#x27;&#x27;,  avatar: &#x27;&#x27;,  introduction: &#x27;&#x27;,  roles: [],  createrId: &#x27;&#x27;&#125;const mutations = &#123;  SET_TOKEN: (state, token) =&gt; &#123;    state.token = token  &#125;,&#125;// user loginlogin(&#123; commit &#125;, userInfo) &#123;    const &#123; username, password &#125; = userInfo    return new Promise((resolve, reject) =&gt; &#123;        login(&#123; username: username.trim(), password: password &#125;).then(response =&gt; &#123;            const &#123; token &#125; = response            commit(&#x27;SET_TOKEN&#x27;, token)            setToken(token)            resolve()        &#125;).catch(error =&gt; &#123;            reject(error)        &#125;)    &#125;)&#125;,\n\n登录成功后，state就可以存储user信息了\n\n\n\n\n\n那么接下来就是退出登录了:\n\n\n（1）在 api&#x2F;user.js 中定义退出方法：\nexport async function logout(param)&#123; return await requestHttp.post(&#x27;/rental/auth/logout&#x27;,param)&#125;\n\n\n\n（2）在 utils&#x2F;auth.js 中定义清除 sessionStorage 方法：\nexport function removeSessionStoreage()&#123;    return sessionStorage.clear()&#125;\n\n\n\n（3） 修改 layout&#x2F;components&#x2F;Navbar.vue 文件：\nimport &#123;logout&#125; from &#x27;@/api/user&#x27;import &#123;getToken, removeToken, removeSessionStorage&#125; from &#x27;@/utils/auth&#x27;logout() &#123;      //修改logout方法     //await this.$store.dispatch(&#x27;user/logout&#x27;)     //this.$router.push(`/login?redirect=$&#123;this.$route.fullPath&#125;`)     this.$confirm(&#x27;确定退出系统吗?&#x27;, &#x27;提示&#x27;, &#123;       confirmButtonText: &#x27;确定&#x27;,       cancelButtonText: &#x27;取消&#x27;,       type: &#x27;warning&#x27;    &#125;).then(async() =&gt; &#123;       let token = &#123; token: getToken &#125;    // 获取token       let res = await logout(token)      // 调用退出登录方法       if (res.success)&#123;         removeToken()\t// 去除token         removeSessionStoreage()    // 清除SessionStoreage             this.$router.push(`/login?redirect=$&#123;this.$route.fullPath&#125;`)      &#125;    &#125;).catch(() =&gt; &#123;       this.$message(&#123;         type: &#x27;info&#x27;,         message: &#x27;已取消退出&#x27;      &#125;);   &#125;);&#125;\n\n\n\n\n\n前端之动态路由菜单登录时获取了用户信息和路由信息，其中用户信息存储在 store&#x2F;modules&#x2F;user.js 的state中，而获取的路由信息得转化为动态路由菜单，好的，现在我们来开始这一部分：\n\n\n\n在 api&#x2F;user.js 中，写获取菜单的方法:\nexport async function getMenuList()&#123;    return await requestHttp.get(&#x27;/rental/auth/menuList&#x27;)&#125;\n\n\n\n修改 store&#x2F;permission.js 文件，实现动态路由菜单\nconst actions = &#123;    generateRoutes(&#123; commit &#125;, roles) &#123;        return new Promise((resolve, reject) =&gt; &#123;            getMenuList().then(response =&gt; &#123;                if (response.code === 200) &#123;                    const accessedRoutes = filterAsyncRoutes(response.data, roles)                    commit(&#x27;SET_ROUTES&#x27;, accessedRoutes)                    resolve(accessedRoutes)  // 进行索引导航                &#125; else &#123;                    reject(response.msg)                &#125;            &#125;).catch(                error =&gt; &#123;                    reject(error)                &#125;)        &#125;)    &#125;&#125;// 此时getMenuList()的response.data要经过filterAsyncRoutes递归处理export function filterAsyncRoutes(routes, roles) &#123;    const res = []    routes.forEach(route =&gt; &#123;        const tmp = &#123; ...route &#125;        if (hasPermission(roles, tmp)) &#123;            let component = tmp.component  // 组件对应permission中的route_url            if (route.component) &#123;                if (component === &#x27;Layout&#x27;) &#123;                    tmp.component = Layout  // 默认布局已经存在该组件                &#125; else &#123;                    tmp.component = (resolve) =&gt; require([`@/views$&#123;component&#125;`],                                                         resolve)                &#125;            &#125;            if (tmp.children) &#123;                tmp.children = filterAsyncRoutes(tmp.children, roles)            &#125;            res.push(tmp)        &#125;    &#125;)    return res&#125;const mutations = &#123;    SET_ROUTES: (state, routes) =&gt; &#123;        state.addRoutes = routes        state.routes = constantRoutes.concat(routes)    &#125;&#125;// 经过处理后的routes保存在route的routes属性中const state = &#123; routes: [], addRoutes: []&#125;\n\n\n\n好，我们来总结一下动态索引菜单是如何进行的：向后端请求得到数据后，用filterAsyncRoutes递归处理索引路径 component, 就可以进行存储和转换了。\n\n\n\n\n最后，还有一些细节需要修改：\n（1）修改router-&gt;index.js文件，注释掉document和guide菜单，并将dashboard改成”首页”字样\n（2）修改utils-&gt;validate.js文件，对用户名的校验\nexport function validUsername(str) &#123;    //const valid_map = [&#x27;admin&#x27;, &#x27;editor&#x27;]    return str.length&gt;0;&#125;\n\n（3）修改layout-&gt;components-&gt;Navbar.vue文件\nlogout() &#123;      //修改logout方法     //await this.$store.dispatch(&#x27;user/logout&#x27;)     //this.$router.push(`/login?redirect=$&#123;this.$route.fullPath&#125;`)     this.$confirm(&#x27;确定退出系统吗?&#x27;, &#x27;提示&#x27;, &#123;       confirmButtonText: &#x27;确定&#x27;,       cancelButtonText: &#x27;取消&#x27;,       type: &#x27;warning&#x27;    &#125;).then(async() =&gt; &#123;       let token = &#123; token: getToken &#125;    // 获取token       let res = await logout(token)      // 调用退出登录方法       if (res.success)&#123;         removeToken()\t// 去除token         removeSessionStoreage()    // 清除SessionStoreage             // this.$router.push(`/login?redirect=$&#123;this.$route.fullPath&#125;`)         window.location.href = &#x27;/&#x27;      &#125;    &#125;).catch(() =&gt; &#123;       this.$message(&#123;         type: &#x27;info&#x27;,         message: &#x27;已取消退出&#x27;      &#125;);   &#125;);&#125;\n\n\n\n\n\n\n\n结语目前已经完成了项目的前端大体框架，后续在进行访问权限模块和项目各部分模块之间的关系总结。\n(&#x2F;ω＼)\n","categories":["vue","vue-element-admin","java项目","汽车租赁管理系统"],"tags":["vue"]},{"title":"vue-element-admin之财务管理","url":"/2025/04/24/%E7%BB%9F%E8%AE%A1%E5%9B%BE_excel%E5%AF%BC%E5%87%BA_%E5%8F%91%E9%82%AE%E4%BB%B6/","content":"介绍：在这一部分，我们可以学习三个小知识： echarts 统计图， excel 导出 和 发送邮件。\n\n\n\n一.  echarts统计图\n\necharts中文官网, 这里我们只看重叠折线统计图，简要思路就是 x轴数据为小时或日期数组，而series的数组为所展现的数据的大小，这两部分的数组索引一一对应。\n\n\n示例效果：\n\n\n\n\n&lt;el-card&gt;    &lt;div&gt;        &lt;div ref=&quot;Mychart&quot; :style=&quot;&#123; width: &#x27;80%&#x27;, height: &#x27;400px&#x27; &#125;&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/el-card&gt;&lt;script&gt;export default &#123;    data() &#123;        return &#123;            Mychart: null,            xArray: [],            y1Array: [],        &#125;    &#125;,        mouted() &#123;      this.initRentalChart();    &#125;,        methods: &#123;        initRentalChart() &#123;            this.Mychart = echarts.init(this.$refs.Mychart);            this.Mychart.setOption(&#123;                title: &#123;                    text: &#x27;日报出租数据统计&#x27;,                    subtext: new Date().toLocaleDateString(),                &#125;,                tooltip: &#123; // 一些例如点选的效果                    trigger: &#x27;axis&#x27;,                    axisPointer: &#123;                        type: &#x27;shadow&#x27;                    &#125;                &#125;,                legend: &#123;                    data: [&#x27;出租数量&#x27;] // series内容数组                &#125;,                grid: &#123;                    left: &#x27;3%&#x27;,                    right: &#x27;4%&#x27;,                    bottom: &#x27;3%&#x27;,                    containLabel: true                &#125;,                toolbox: &#123;                    show: true,                    orient: &#x27;vertical&#x27;,                    left: &#x27;right&#x27;,                    top: &#x27;center&#x27;,                    feature: &#123; // 侧边栏：数据展示，图的切换，保存图片                        mark: &#123;show: true&#125;,                        dataView: &#123;readOnly: false, show: true&#125;,                        magicType: &#123;                            type: [&#x27;line&#x27;, &#x27;bar&#x27;],                            show: true                        &#125;,                        saveAsImage: &#123;show: true&#125;                    &#125;                &#125;,                xAxis: &#123;                    type: &#x27;category&#x27;,                    boundaryGap: false,                    axisTick: &#123;show: false&#125;,                    data: this.xArray                &#125;,                yAxis: &#123;                    type: &#x27;value&#x27;                &#125;,                series: [                    &#123;                    name: &#x27;出租数量&#x27;,                    // type: &#x27;bar&#x27;,                    type: &#x27;line&#x27;,                    // stack: &#x27;Total&#x27;,                    barGap: 0,                    data: this.y1Array                    &#125;,                ]            &#125;);        &#125;,    &#125;&#125;&lt;/script&gt;\n\n\n\n\n\n\n\n二. excel导出\n\n将对象数组转化为excel表，属性作为表头，可以起别名哦🎃。需要 hutool 依赖包来完成：\n\n\n导出效果：\n\n\n\n\nimport cn.hutool.poi.excel.ExcelUtil;import cn.hutool.poi.excel.ExcelWriter;@GetMapping(&quot;exportExcel&quot;)public void export(HttpServletResponse response) throws IOException &#123;    List&lt;AutoBrand&gt; list=autoBrandService.list();    // 列表转化为excel文件    ExcelWriter writer= ExcelUtil.getWriter(true);    writer.addHeaderAlias(&quot;brandName&quot;,&quot;品牌名称&quot;);    writer.addHeaderAlias(&quot;deleted&quot;,&quot;是否删除&quot;);    writer.write(list,true);    // 设置response格式和传输的文件名    response.setContentType(&quot;application/vnd.openxmlformats-                            officedocument.spreadsheetml.sheet;charset:utf-8&quot;);    String fileName= URLEncoder.encode(&quot;汽车品牌&quot;,StandardCharsets.UTF_8);    response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;                       filename=&quot;+fileName+&quot;.xlsx&quot;);                                      \t  writer.flush(response.getOutputStream(),true);    writer.close();&#125;\n\n\n\n\n\n\n\n三. 发邮件\n\n\n进行application.yml配置:\nspring:  mail:    host: smtp.163.com # smtp为简单邮件协议    port: 25    username: a838211536@163.com # 邮箱名    password: QNg9GeYBpeybQRMT # 授权密码    properties:      mail.smtp.auth: true # 启用认证      mail.smtp.starttls.enable: true  # 启用TLS      mail.smtp.starttls.required: true\n\n\n\n定义IMailService接口及其实习类MailServiceImpl, 需注意：如果javaMailSender无法自动注入的话，还需要自己写一个产生 javaMailSender bean 的配置类。\n\n\n@Servicepublic class MailServiceImpl implements IMailService &#123;    @Autowired    private JavaMailSender javaMailSender;    /**     * 发送邮件     *     * @param mail 邮件数据对象，包含以下关键字段：     *             - from:    发件人地址     *             - to:      收件人地址（支持多个）     *             - subject: 邮件主题     *             - content: 邮件正文内容     * 实现说明：     * 1. 使用SimpleMailMessage构建基础邮件信息     * 2. 设置发件人、收件人、主题、正文等核心字段     * 3. 将发件人同时添加到抄送列表（需确认是否符合业务需求）     * 4. 通过JavaMailSender执行邮件发送     *     * @throws MailException 当邮件发送失败时抛出相关异常     */    @Override    public void sendMail(MailVO mail) throws MailException &#123;        // 构建基础邮件消息对象        SimpleMailMessage message = new SimpleMailMessage();        // 设置邮件基本信息        message.setFrom(mail.getFrom());        message.setTo(mail.getTo());        message.setSubject(mail.getSubject());        message.setText(mail.getContent());        // 设置发件人同时作为抄送（根据业务需求可能需要调整）        message.setCc(mail.getFrom());        // 执行邮件发送操作        javaMailSender.send(message);    &#125;\n\n\n\n好的，到这里就可以进行邮件发送操作了，但是如何进行定时发送邮件呢？\n\n\n定时发送邮件, 这里就以财务管理的日报收入部分为例吧：\n@Componentpublic class SendMailUtil &#123;    @Autowired    private IFinanceService financeService;    @Autowired    private IMailService mailService;    @Value(&quot;$&#123;spring.mail.username&#125;&quot;)    private String from;    @Scheduled(cron = &quot;*/10 * * * * ?&quot;)    public void sendMail() &#123;        StringBuffer sbf = new StringBuffer();        sbf.append(&quot;今日收入：&quot;)                .append(&quot;，租金收入：&quot;)                .append(financeService.sumRentPay().getCountActualPayable())                .append(&quot;，押金收入：&quot;)                .append(financeService.sumDeposit());        MailVO mailVO = new MailVO();        // 设置四部分：from, to, subject, content        mailVO.setFrom(from);        mailVO.setTo(&quot;a838211536@163.com&quot;);        String date = LocalDate.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));        mailVO.setSubject(date + &quot;今日收入&quot;);        mailVO.setContent(sbf.toString());        mailService.sendMail(mailVO);    &#125;&#125;\n\n\n\n好的，这样看来，邮件发送就简单了：（1）javaMailSender的配置     （2）填写发送信息对象\n\n\n","categories":["vue","vue-element-admin","java项目","汽车租赁管理系统"],"tags":["echarts统计图","excel导出","发邮件"]},{"title":"Spring Security","url":"/2025/04/24/spring-security/","content":"介绍： 是一套后端访问和权限校验的框架，由一系列的过滤链组成，我们主要操作的是三部分：\n\n认证核心（UsernamePasswordAuthenticationFilter） \n\n处理认证和授权异常（ExceptionTranslationFilter）\n\n授权核心（FilterSecurity）\n\n\n我们主要从认证和授权这两个方面来总结。\n\n\n\n\n\n\n一. 认证\n\n认证就是认证核心 UsernamePasswordAuthenticationFilter 过滤器来进行的，我们来看一下流程图：\n\n\n\n\n\n\n\n用户初次登录\n\n具体流程： \n（1）接受用户发送请求携带的username和password，封装为Authentication对象，调用AuthenticaionManager（含有UserDetailsService接口实现类和PasswordEncoder密码校验）\n\n\n（2） UserDetailsService接口实现类根据username查询用户信息，及其权限信息，封装到UserDetails对象实现类里。经过PasswordEncoder的接口实现类BCryptPasswordEncoder的校验，通过校验则将UserDetails接口实现类对象封装到Authentication对象里, 不通过则到登录失败处理器返回登录失败信息。\n\n\n（3）最后将对象返回并且存入SecurityContextHolder.getContext()里。\n\n\n（4）存入并返回token: 通过UsernamePasswordAuthenticationFilter后，到达登录成功处理器LoginSucessHandler，首先根据 Authentication对象 获取 User 对象（封装用户信息和权限信息），再提取 username 和 userId 生成token, outputStream流返回token并将token，及有效时间长度存储到redis中。\n\n\n\n\n那便有一个问题了，这个登录成功处理器不在这三大过滤器之内呀，如何配置呢？哈哈，要经过SecurityConfig配置的，事实上，SecurityConfig是配置整个安全过滤器链的。\n@Configuration@EnableWebSecurity@EnableMethodSecuritypublic class SecurityConfig &#123;    @Autowired    private LoginSuccessHandler loginSuccessHandler;    @Autowired    private LoginFailHandler loginFailHandler;    @Autowired    private CustomerAccessDeniedHandler customerAccessDeniedHandler;    @Autowired    private CustomerAnonymousEntryPoint customerAnonymousEntryPoint;    @Autowired    private CustomerUserDetailsService customerUserDetailsService;    @Autowired    private  VerifyTokenFilter verifyTokenFilter;    /**     * 配置安全过滤器链     * @param http     * @return     * @throws Exception     */    @Bean    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;        // 登录前过滤配置        http.addFilterBefore(verifyTokenFilter, UsernamePasswordAuthenticationFilter.class);        //        http.formLogin()                .loginProcessingUrl(&quot;/rental/user/login&quot;) // 设置登录处理URL                .successHandler(loginSuccessHandler) // 设置登录成功处理器                .failureHandler(loginFailHandler) // 设置登录失败处理器                .and()                .sessionManagement()                .sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 设置会话创建策略为无状态                .and()                .authorizeHttpRequests() // 授权请求配置                .requestMatchers(&quot;/rental/user/login&quot;) // 匹配登录请求                .permitAll() // 允许所有请求访问                .anyRequest().authenticated() // 任何其他请求需要认证                .and()                .exceptionHandling() // 异常处理配置                .authenticationEntryPoint(customerAnonymousEntryPoint) // 设置未认证入口点                .accessDeniedHandler(customerAccessDeniedHandler) // 设置访问拒绝处理器                .and()                .cors() // 跨域配置                .and()                .csrf().disable() // 关闭CSRF保护  跨站请求伪造 是一种网络攻击                .userDetailsService(customerUserDetailsService); // 设置用户详情服务        return http.build(); // 构建并返回安全过滤链    &#125;&#125;\n\n\n\n\n\n我们可以看到配置的内容为：\n登录前：UsernamePasswordAuthenticationFilter\n登录失败，登录成功\n请求访问策略\n异常处理\n跨域配置\nuserDetailsService接口实现类\n\n\n\n\n\n用户携带token登录具体流程：用户携带token访问非login的url需要经过verifyTokenFilter验证，token为空，不在redis内，不可解析则抛出认证异常被登录失败处理器捕捉，否则解析username，调用UserDetailsService接口实现类进行查询用户信息和权限信息，封装到Authentication对象并存储到SecurityContextHolder.getContext()里。\n\n\n\n\n\n\n二. 授权\n\n\n前面我们调用UserDetailService实习类loadByUserName方法查询权限信息并且存储到UserDetail的实现类中，我们来看一下权限信息的创建过程：\n\n// 查询权限信息List&lt;Permission&gt; permissionList = permissionService.selectPermissionListByUserId(user.getId());user.setPermissionList(permissionList);// 通过stream流处理，将权限对象转化为权限字符串列表List&lt;String&gt; list = permissionList.stream().filter(Objects::nonNull)    .map(Permission::getPermissionCode)    .filter(Objects::nonNull)    .toList();String[] array = list.toArray(new String[list.size()]);List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.createAuthorityList(array);user.setAuthorities(authorityList);\n\n\n\n可以看到权限信息是根据permissionCode字段进行创建的。\n\n\n\n现在已知权限信息的具体格式，接下来看看具体的授权操作，以新增角色为例：\n@PostMapping@PreAuthorize(&quot;hasAuthority(&#x27;sys:role:add&#x27;)&quot;)public Result add(@RequestBody Role role) &#123;    role.setDeleted(false);    return roleService.save(role) ?  Result.success() : Result.fail();&#125;\n\n需要 PreAuthorize 注解 和 hasAuthority 方法就好了，方法参数即为上面提交的permissionCode😁\n\n\n现在授权大体已经讲完了，另外还可以自己定义hasAuthority方法呦🎃，我们来看看过程吧：\n@Component(&quot;ex&quot;)public class MyExpressionRoot &#123;    public boolean hasAuthority(String authority)&#123;        //获取身份令牌        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();        //获取权限        Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();        //循环判断        for (GrantedAuthority grantedAuthority : authorities) &#123;            String role = grantedAuthority.getAuthority(); // 获取string            if (role.equals(authority)) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;// 使用：@PreAuthorize(&quot;@ex.hasAuthority(&#x27;&#x27;)&quot;)\n\n结语好了，现在spring security已经总结完了，慢慢学习，思考和总结，熟练了就简单了😁\n","categories":["java项目","汽车租赁管理系统","java框架","SpringSecurity"],"tags":["SpringSecurity"]},{"title":"核心业务逻辑","url":"/2025/04/25/%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/","content":"介绍：总结一下汽车租赁管理系统的核心业务逻辑，有四大板块：\n（1）权限管理\n（2）数据初始\n（3）日常业务\n（4）财务管理\n这样是按照开发顺序来排的：我们的项目首先登录进去，根据登录用户的权限信息显示左侧菜单栏，车辆信息要进行设置，然后可以操作日常业务板块了，最后可以进行财务管理。\n\n\n\n\n一. 权限管理\n\n这一模块是我们整个项目的基础，用户—角色—权限资源 这三大部分相关联，当然还有部门—用户，这里主要介绍重点： 权限资源 permission 表，表中包含了四大板块所有的权限及其子权限。\n\n\n四大板块的权限分级：顶级目录(0), 菜单(1), 操作(2) \n\n\n那么就有一个问题了，我们登录用户的权限和这四大板块的权限有啥关系呀？其实可以从访问和操作这两部分出发：\n（1）访问： 顶级目录和菜单部分\n\n\n（2）操作：增删改查\n\n\n简单点说，就是，你用户的权限包含顶级目录和菜单，就可以在菜单侧边栏显示，再包含相关操作权限，就可以对相关页面进行相关操作。如果用户权限包括权限管理及其所有子权限，就可以在该板块编辑自己或其他用户的权限资源分配。\n\n\n了解了具体原理后，我们来看看这四个部分的功能\n\n部门管理：增删改查\n\n用户管理：增（选择部门，先删关联再添关联），删（删除与角色的关联），改，查，绑定角色\n\n角色管理：增，删（删除与用户关联，删除与权限关联），改，查，设置权限\n\n菜单管理：增删改查\n\n\n\n\n二. 数据初始\n\n这一部分就是设置车辆信息的，效果图如下：\n\n\n我们直接来看操作：\n\n车辆厂商：增删改查\n\n车辆品牌：增（选择车辆厂商），删，改，查（显示厂商名称）\n\n出租类型：增删改查\n\n车辆信息：增（所属厂商，所属品牌），删，改，查\n\n\n\n\n三. 日常业务\n\n这一部分就是重中之重了，效果图如下：\n\n\n（1）客户管理：增删改查\n（2）汽车出租：管理为出租的汽车，查（汽车status&#x3D;0），出租（填写出租类型和用户信息–&gt; 新增订单, 修改汽车状态status&#x3D;1）\n（3）订单详情：查询，订单详情，押金返还\n（4）违章处理：增（车牌号，违章信息），删，改，查\n（5）车辆保养：增（查询需要保养的车牌号），删，改，查\n（6）车辆归还：管理未归还的车辆，显示用户信息，车辆信息，订单信息，出租类型的联合查询。查询，归还\n\n\n\n\n四. 财务管理\n\n主要是 echarts 统计图，excel表导出，定期发邮件这三部分，之前已经总结了，请参考：\nvue-element-admin\n","categories":["java项目","汽车租赁管理系统"]},{"title":"算法刷题之前言","url":"/2025/04/25/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E4%B9%8B%E5%89%8D%E8%A8%80/","content":"介绍：回想自己学习算法的过程，先是大致看完了K神的《Hello算法》java版，又在leetcode中刷了大概30题，ε&#x3D;(´ο｀*)))唉，因为最近做项目把握不准时间，每天最后总是没时间刷题，写下来反思反思，每天刷两题，每天记录记录自己的刷题感受，十天为单位发一篇文章，监督自己的进度顺便总结一下K神的Hello算法部分，加油！\n","categories":["算法刷题"],"tags":["算法"]},{"title":"百日筑基之前言","url":"/2025/04/25/%E7%99%BE%E6%97%A5%E7%AD%91%E5%9F%BA%E4%B9%8B%E5%89%8D%E8%A8%80/","content":"今天我定一个百日筑基的计划，内容为戒色和锻炼，之前也尝试过，但都以失败告终，回想坚持最长的一段时间，是在戒色文章和戒色口号的熏陶下，原本我以为形式化的意义不大，但事实证明环境对一个人的影响极大，聪明的人总能把自己置于合适的环境，赋予自己驱动力和执行力，当然，这一切的前提是心中宏大的志向。所以，今天我发起百日筑基计划，每天记录自己学习戒色的知识和锻炼的感受，十天为一篇文章，分享自己的心得感悟。\n","categories":["百日筑基"]},{"title":"Linux部署java环境","url":"/2025/04/26/Linux%E9%83%A8%E7%BD%B2java%E7%8E%AF%E5%A2%83/","content":"远程连接工具FinalShell, 功能：ssh, ftp\n\n\n一. 安装配置JDK\n\n\n利用FinalShell上传文件功能上传 jdk 安装包\n\n\n解压： tar -zxvf 安装包名 -C 解压目录, 这里我的解压目录是 &#x2F;usr&#x2F;local\n\n\n配置环境变量：操作文件 &#x2F;etc&#x2F;profile，在文件末尾加上：\nJAVA_HOME=/usr/local/jdk1.8.0_171PATH=$JAVA_HOME/bin:$PATH\n\n\n\n重新加载文件，检查是否配置成功：\nsource /etc/profilejava -version\n\n\n\n\n\n二. 安装配置Tomcat\n\n\n利用FinalShell上传安装包并解压到 &#x2F;usr&#x2F;local&#x2F;\n\n\n启动tomcat\ncd /usr/local/tomcat文件父目录/binsh startup.sh\n\n\n\n查看tomcat运行进程，有两种方式：\n（1）tomcat 启动日志 catalina.out\n// 查询日志文件尾部的50行记录tail -50 /usr/local/apache-tomcat-7.0.57/logs/catalina.out\n\n（2）查看并筛选系统进程\nps -ef|grep tomcat\n\n\n\n那么现在进行启动了，就该看看防火墙了。\n// 先开启系统防火墙systemctl start firewalld// 再开放8080端口号firewall-cmd --zone=public --add-port=8080/tcp --permanent// 重新加载防火墙firewall-cmd --reload\n\n\n\n停止Tomcat，两种方式:\n（1）tomcat脚本\n// tomcat中的bin目录下：sh shutdown.sh\n\n\n\n（2）结束tomcat进程\nps -ef|grep tomcatkill -9 tomcat进程号\n\n\n\n\n\n三. 安装配置MySQL\n\n\ncentos或者RHEL系统自带mariadb数据库，这个数据库和MySQL数据库是冲突的，所以要想保证MySQL成功安装，需要卸载mariadb数据库。\n// 查看指定软件是否存在rpm -qa | grep mariadb查询当前系统中安装的名称带mariadb的软件rpm -qa | grep mysql查询当前系统中安装的名称带mysql的软件// 卸载软件// 语法: rpm -e --nodeps 软件名称rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64\n\n\n\n上传并解压, 需要自己创建mysql父目录\n\n\n按照顺序安装rpm安装包\nrpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpmyum install net-toolsrpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm\n\n\n\n启动mysql\nsystemctl status mysqld // 查看mysql服务状态systemctl start mysqld // 启动mysql服务systemctl stop mysqld // 停止mysql服务systemctl enable mysqld // 开机自启\n\n\n\n查看\nnetstat -tunlp | grep mysql // 查看mysql的服务信息ps –ef | grep mysql // 查看mysql进程\n\n\n\n登录\n初次登录查看默认生成的密码：\ncat /var/log/mysqld.log | grep password\n\n登录并修改密码：\nmysql -uroot -pset global validate_password_length=4; //设置密码长度最低位数set global validate_password_policy=LOW; //设置密码安全等级低，便于密码可以修改成rootset password = password(&#x27;root&#x27;); // 设置密码为root// 开启访问权限grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;root&#x27;;flush privileges;\n\n\n\n远程登录: 工具：Navicat\n// 防火墙开启3306端口firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload\n\n\n\n\n\n四. 安装配置Redis\n\n\n安装redis：\n\n\n下载地址：https://download.redis.io/releases/redis-6.2.6.tar.gz 稳定版， 上传安装文件\n\n\n解压，用gcc编译\n解压：tar -zxvf redis-6.2.6.tar.gz -C /opt/编译：cd /opt/redis-6.2.6/make install   // 自动安装到 /usr/local/bin下安装的文件描述：redis-benchmark：性能测试工具redis-check-aof：修复aof持久化文件redis-check-rdb：修复rdb持久化文件redis-cli：redis命令行工具redis-sentinel：redis集群哨兵使用redis-server：启动redis\n\n\n\n后台启动：\ncd /opt/redis-6.2.6cp redis.conf  redis_1.confvim redis_1.conf将daemonize的no改成yes（查找内容：/+内容 enter n）redis-server redis_1.conf\n\n\n\n启动命令行和退出redis\n命令行启动：redis-cli退出redis:(1) 先shutdown,再执行exit(2) 先exit,再杀死redis进程id\n\n\n\n\n\n五. 安装lrzsz\n\n很多的远程连接工具并没有上传下载的功能，这个时候就需要依赖于lrzsz这个软件了。\n\n\n\n所有lrzsz安装包\nyum list lrzsz\n\n\n\n在线安装lrzsz：\nyum install lrzsz.x86_64\n\n\n\n输入rz，弹出上传的窗口，选择上传的文件\n \n\n\n\n六. 项目部署\n\n（1）手动部署项目：\n\n\n\n打包，利用lrzsz的rz命令上传，运行命令： java -jar 包名 \n\n\n那我们关闭命令行，这个时候不炸了吗？🎃，我们可以后台运行项目，将日志输出到日志文件：\nnohup java -jar helloworld-1.0-SNAPSHOT.jar &amp;&gt; hello.log &amp;// nohup: 不挂起// &amp;: 让命令在后台运行\n\n\n\n停止项目：\nps -ef|grep javakill -9 进程号\n\n\n\n\n\n\n\n（2）基于shell脚本自动部署\n\n\n\n将idea中的项目代码推送到远程\n\n\n下载git, 克隆远程代码：\nyum list git // 列出git安装包yum install git // 在线安装gitgit --version  // git安装验证git clone https://gitee.com/youre-not-as-handsome-as-me/demo.git\n\n\n\n上传解压maven安装包到 &#x2F;usr&#x2F;local&#x2F;, 在&#x2F;etc&#x2F;profile文件中配置环境变量：\nvim /etc/profile修改配置文件，进入到命令模式，按G切换到最后一行，按a/i/o进入插入模式，然后在最后加入如下内容 :export MAVEN_HOME=/usr/local/apache-maven-3.5.4export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH重新加载并验证source /etc/profilemvn -v\n\n\n\n在settings.xml配置文件设置本地仓库和私服：\nvim /usr/local/apache-maven-3.5.4/conf/settings.xml&lt;localRepository&gt;/usr/local/repo&lt;/localRepository&gt;阿里私服：&lt;mirror&gt;\t&lt;id&gt;alimaven&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;aliyun maven&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;&lt;/mirror&gt;\n\n\n\n编写shell脚本bootStart.sh执行部署流程：\n#!/bin/shecho =================================echo  自动化部署脚本启动echo =================================echo 停止原来运行中的工程APP_NAME=demotpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`if [ $&#123;tpid&#125; ]; then    echo &#x27;Stop Process...&#x27;    kill -15 $tpidfisleep 2tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`if [ $&#123;tpid&#125; ]; then    echo &#x27;Kill Process!&#x27;    kill -9 $tpidelse    echo &#x27;Stop Success!&#x27;fiecho 准备从Git仓库拉取最新代码cd /usr/local/demoecho 开始从Git仓库拉取最新代码git pullecho 代码拉取完成echo 开始打包output=`mvn clean package -Dmaven.test.skip=true`cd targetecho 启动项目nohup java -jar demo-0.0.1-SNAPSHOT.jar &amp;&gt; demo.log &amp;echo 项目启动完成\n\n\n\n赋予bootStart.sh权限, 执行脚本\nchmod 777 bootStart.shsh bootStart.sh\n\n","categories":["Linux"],"tags":["Linux"]},{"title":"SpringCloud-Alibaba系列之Nacos","url":"/2025/05/05/SpringCloud-Alibaba%E7%B3%BB%E5%88%97%E4%B9%8BNacos/","content":"介绍：Nacos是SpringCloud Alibaba的五大组件之一，是一个服务注册中心，主要功能为管理注册的服务，配置服务，为服务之间的访问提供DNS解析，可以设置负载均衡。\n\n\n\n\n一. 注册服务及服务之间的访问\n\n（1）服务是如何注册到Nacos从而被Nacos管理的呢？\n\n很简单，就是导入一个发现Nacos的依赖包（nacos client依赖），再通过application.yml配置文件进行注册：\n&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;\n\napplication.yml:\nserver:  port: 9002spring:  application:    name: consumer-service-nacos  # 注册到Nacos的服务名称  cloud:    nacos:      discovery:        server-addr: localhost:8848 # Nacos在本地启动的默认端口        username: nacos  # 登录Nacos的用户名和密码，用于访问验证        password: nacos        namespace: 0ffbe532-ae84-4010-ade3-591db18d33e1 # 命名空间的id        group: dev # 组\n\n\n\n\n\n（2）注册到Nacos的服务要如何访问Nacos的其他服务呢？这个时候就要用到RestTemplate对象了，我们进行一个自动配置：\n@Configurationpublic class ConfigBean &#123;    @Bean    public RestTemplate restTemplate() &#123;        return new RestTemplate();    &#125;&#125;\n\n使用restTemplate的不同方法访问其他服务，访问的地址为\nhttp://服务名\n\n\n\n这个时候有一个问题了，如果要访问的这个服务名下有多个不同的服务（端口不同），该访问拿一个呢？这个时候就要用到负载均衡了，只需在RestTemplate生成bean的方法加上 LoadBalanced 注解\n@Configurationpublic class ConfigBean &#123;    @Bean    @LoadBalanced    public RestTemplate restTemplate() &#123;        return new RestTemplate();    &#125;&#125;\n\n\n\n\n\n（3）注册服务时有那些细节需要注意呢？\n注册的是临时实例还是永久实例，有什么区别？\nspring:  cloud:    nacos:      discovery:        ephemeral: false # false为永久实例，true为临时实例，默认为临时实例\n\n\n\n区别：\n临时实例和永久实例的区别在于能否被删除，临时实例依靠心跳机制存活，默认间隔为5秒，15秒未应答就是不健康状态，30秒未应答就删除。永久实例则不会删除，实例不存在时就标记为不健康状态。\n临时实例的模式为AP(可用性和分区容错性)， 基于discro协议，只返回可以使用的数据，不一定是最新数据，强调的是数据的可用性。而永久实例的模式为CP(一致性和分区容错性)，基于raft协议实现，返回最新的数据或者错误，强调的是数据正确。\n\n\n集群\n\n如何设置负载均衡访问的权重？保护阈值是什么，如何设置？\n\n\n假如在nacos服务端中一个服务名下有多个端口，可以设置不同端口的权重，那在消费端中配置：\nspring:  cloud:    loadbalancer:      nacos:        enabled: true\n\n\n\n接上述所讲，一个服务名下有多个端口，可以设置该服务的保护阈值（0-1的浮点数），如果健康的端口数所占比例小于或等于保护阈值，那么nacos将全部实例（包括不健康的实例）返回给调用端，防止发生雪崩效应。\n\n\n\n\n二. Nacos集群\n\nNacos集群中Nacos节点的数量大于或等于3，单个Nacos使用内嵌数据库derby，Nacos集群使用MySQL（集中式处理）。\n\n\nNacos集群如何配置和启动？\n在mysql创建数据库，运行Nacos的数据表sql语句：nacos目录下&gt;conf&gt;mysql-schema.sql，这个时候集群的数据库就已经搭建好了，如果有服务要连接该集群，必须配置连接该MySQL数据库:\nspring:  datasource:    url: jdbc:mysql://localhost:3306/testcloud    username: root    password: 123456    driver-class-name: com.mysql.cj.jdbc.Driver\n\n到nacos的各个节点的application.properties配置文件中修改MySQL的数量和库名，数据库部分介绍完了，该到集群配置启动部分了，到nacos的各个节点的cluster.conf下，添加集群中所有节点的ip和端口号，最后使用startup命令启动各个节点既可。\n\n\n有一个点需要注意，在nacos2.x以后，除了启动的Http端口外，还有gRPC的通信方式，是在Http端口基础上加上偏移量，所以同一台服务器上模拟Nacos集群时，各个节点的Http端口不要相邻。\n\n\n\n\n三. Nacos配置中心\n\n设立配置中心，方便管理各个服务的配置，这个时候服务只需要连接到配置中心中指定的配置文件既可获取它自己的配置，来进行启动。\n\n\n\n在配置中心创建配置文件，各个服务是如何从配置中心里获取到它们的配置文件的？\n\n\n创建一个命名空间，或者选中命名空间，创建配置文件过程中设置组\n\n\n各个服务导入nacos-config依赖包：\n&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置文件：\nspring:  application:    name: consumer-service-nacos-config  cloud:    nacos:      config:        server-addr: localhost:8848        username: nacos        password: nacos        file-extension: yml        # namespace:        # group:   config:    import: optional:nacos:$&#123;spring.application.name&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;    # 多个配置文件的读取时，后者会覆盖前者\n\n\n\n\n\n配置中心和客户端的数据是如何同步的？\n\n\n通过长轮询的pull模式，即客户端向服务端发送获取配置的请求，服务端不会立即响应而是将请求挂起等待一段时间，如果这段时间内，配置文件发生变化，就立即响应请求，否则，就等超时之后响应请求。当客户端接受到响应请求后就再次发送长轮询请求，如此一直进行来保证配置文件的数据同步。\n\n\n","categories":["java框架","SpringCloud-Alibaba"],"tags":["SpringCloud-Alibaba","Nacos"]},{"title":"百日筑基之第一阶段","url":"/2025/05/05/%E7%99%BE%E6%97%A5%E7%AD%91%E5%9F%BA%E4%B9%8B%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/","content":"百日筑基自2025.4.25发起，今天是2025.5.5，已经过了10天，完成进度1&#x2F;10，讲讲感受吧，就是挺好的，体力精力明显地感觉有提升。体力方面一口气以寻常速度爬三楼呼吸正常，不喘气，爬五楼稍微喘气，平常快走无压力，挺胸直背比之前轻松。精力的话就最近，到了9,10天的样子吧，学习时比原先的精力更充沛了，心态慢慢回正了，有一个特别的感受，就是每天都会对明天有期盼，期待自己的百日筑基进度又向前推进了，自己的体力和精力一天比一天更强大，这种感觉很棒，好极了，哈哈，这就是百日筑基第一阶段的总结了，继续加油！\n","categories":["百日筑基"]},{"title":"面试系列之Mybatis","url":"/2025/05/08/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E4%B9%8BMybatis/","content":"一. 基本实现现在我们的Springboot + Mybatis是如何配置的呢？\n\n\npom.xml文件：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.4&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n实现 mapper, service, controller 三层结构，注意 mapper.xml 文件要定义在 src&#x2F;main&#x2F;resources&#x2F;mapper下，就要在 application.yml 配置 mapper.xml 文件路径，完整的 application.yml 文件如下：\nserver:  port: 8080spring:  application:    name: mybatistest  # 连接池  datasource:    url: jdbc:mysql://localhost:3306/mybatistest?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false    username: root    password: 123456  # mybatis日志打印到控制台mybatis:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  # 指定mapper.xml文件的路径  mapper-locations: classpath:mapper/*.xml\n\n\n\n这个时候就可以了😁\n\n\n\n\n二. 具体原理那么一条sql语句在Mybatis中是如何执行的呢？从上面看，是 mapper.xml 和 mapper 接口相关联，然后调用mapper接口，我们只需要关注mapper的关联和sql语句的编写就行。\n\n\n【说说Mybatis的具体执行流程】\n\n\n\n\n我就总结一下吧：首先读取mybatis的xml配置（包含了对mapper.xml文件的映射），讲这些配置转化为流，作为sqlSessionFactoryBuilder的build方法的参数去生成了sqlSessionFactory，然后sqlSessionFactory创建sqlSession，sqlSession去调用Executor执行器去执行sql语句。在执行前将需要映射的参数信息保存到MapperStatement对象中，执行的过程是执行器调用StatementHandler预编译，再调用ParameterHandler设置编译参数，最后用TypeHandler将javaBean类型和数据库类型进行映射处理，调用原生的JDBC的API执行sql语句。如果返回结果，TypeHandler将数据库类型映射到javaBean类型，这个时候可能出现查询字段和对象属性不一致的情况，就可以用resultMap进行手动映射，如果想要将数据库的某个类型固定地转化为java的某个类型，就可以自己自定义TypeHandler, 最后就通过ResultSetHandler来处理查询结果。\n\n\n我认为了解mybatis执行流程对于日常的实际使用作用最大的还是TypeHanlder类型映射只一块，实现数据库类型和java类型的映射，平常报错最多的也是这一块。\n\n\n\n\n三. 延迟加载和缓存\n\n【说说Mybatis延迟加载的原理】\nMybatis延迟加载就是如果查询的主对象中包含了一些关联对象，那么这些关联对象不会立刻加载，只有使用时才会被加载，这样就避免查询不必要的数据，提升查询性能。\n具体的原理就是查询主对象时，Mybatis就会利用CGLIB动态代理生成一个代理对象，代理的目标对象就是开启了延迟加载的mapper，调用目标方法时，就会进入拦截器的invoke方法，如果目标是空值，就会继续sql查询，查询的结果填充到代理对象中，如果下次查询到相同的关联对象时，就可以获取。\n\n\n具体的配置就是在 resultMap 类型映射一些属性或者对象的时候，将 association 标签的 fetchType 属性设置为 lazy。\n\n\n\n\n【说说Mybatis的缓存机制】\nMybatis主要有一级缓存和二级缓存。\n一级缓存的范围是sqlSession，是由执行器来完成的，比如默认执行器SimpleExecutor的父类BaseExecutor就创建了PerpetualCache缓存对象，其实就是一个HashMap对象。当进行增删改数据或者sqlSession关闭之后，就会清空缓存数据。\n二级缓存的范围是mapper.xml的namespace，不是依赖于sqlSession，默认也是采用PerpetualCache缓存对象，HashMap存储。如果想要开启二级缓存的话，需要在全局配置文件和具体的映射文件开启配置才行。\n","categories":["java面试"],"tags":["Mybatis"]},{"title":"面试系列之Spring","url":"/2025/05/09/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E4%B9%8BSpring/","content":"先把Spirng结构放在这里，方面后续的整体理解🎃\n\n\n\n\n\n\n热身环节每次都开始将知识，感觉有点枯燥🤣，加个热身环节过渡过渡😁。首先我们先进入热身环节，就是以一个学生的增删改查案例来讲讲SSM框架吧🎃\n\n\nSSM框架是个啥？就是Spring容纳Spring MVC（基于Servlet API）和 Mybatis这两个小弟。瞧到上面的Spring框架结构图没有？没错，我们的 Data Access 和 Web部分就分别交给这两个小弟了，Mybatis小弟调用原生的JDBC，还差个啥呢？就是数据库的连接了：数据库驱动和连接池。 SpringMVC小弟还差啥呢？我们想想MVC是不是model，view和controller，那view和controller不就要 JSP API 和Servlet API嘛。\n\n\n搞清楚了SSM以及需要啥，那我们就可以看看 pom.xml 文件了：\n&lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.13.1&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--mysql驱动--&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;8.0.33&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--dataSource--&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;druid&lt;/artifactId&gt;      &lt;version&gt;1.2.12&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--lombok--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;      &lt;artifactId&gt;lombok&lt;/artifactId&gt;      &lt;version&gt;1.18.36&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--mybatis--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;      &lt;version&gt;3.5.19&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;      &lt;version&gt;2.0.7&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--spring--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;5.3.15&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;      &lt;version&gt;5.3.15&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;      &lt;version&gt;5.3.15&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;      &lt;version&gt;4.0.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;      &lt;version&gt;2.3.3&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n是不是很简单🎃\n\n\n把需要的依赖导进来之后，我们还需要编写Spring配置文件（dataSource,sqlSessionFactory,MapperScannerConfigurer 这些本来是Mybatis小弟需要的，大哥给他做，好大哥👍，那大哥还需要进行注解bean的扫描），Mybatis配置文件（Mybatis小弟表示太感动了，我就只用搞搞entity实体类的别名就行😁），还有SpringMVC的配置文件，我们首先要清楚SpringMVC的工作流程，我们主要配置的是对于处理器而言，即@Controller注解的扫描范围：\n&lt;!--自动扫描--&gt;&lt;context:component-scan base-package=&quot;com.xzit&quot;/&gt;&lt;!--处理器映射器和适配器--&gt;&lt;mvc:annotation-driven/&gt;\n\n\n\n\n\n\n\n最后就是web.xml，这个文件是啥？就是整个SSM框架构成的web应用的部署描述文件，含有Tomcat服务器的核心行为。主要配置SpringMVC的前端控制器，加载非Web层的Spring配置（Service,Dao等Bean）。\n\n\n接下来就是Mapper, Service, Controller三层结构，比如查询所有的学生列表，传递结果给 jsp 文件。就可以做增删改查操作了。\n\n\n好了，SSM热身环节结束，其中Servlet API的SpringMVC，servlet API，JSP API，web.xml 等 web 路径方面的 和 一些 xml 配置文件都有一些过时，但是Spring Web是有SpringMVC演化而来，保留并优化了一部分原有的组件，对于理解SpringBoot有很好的推动作用。\n\n\n\n\n一. Spring核心概念（1）依赖注入（DI）和控制反转（IOC）的基本原理\n\n\n【说说Spring中的IOC是什么？有什么好处？】\nIOC控制反转是将对象的创建和管理的职责交给Spring容器，创建对象并且注入依赖对象这个动作是由IOC容器而不是程序员完成的。\n好处是降低耦合度，类A依赖类B，可以通过注解或者配置文件的方式完成依赖注入，加入类A不依赖类B，只需修改对应的注解或者配置文件。还有一个好处是对象的创建是由IOC容器完成的，创建对象时可以判断是否需要代理，如果需要，就可以直接包装返回代理对象。\n\n\n【Spring中的DI是什么？】\n依赖注入是控制反转的一种机制，创建对象时可以自动将该对象依赖的对象注入进去。\n\n\n【循环依赖是什么？Spring如何解决循环依赖？】\n循环依赖是多个对象相互依赖形成闭环。\n比如A和B循环依赖，先实例化A，包装成ObjectFactory存入三级缓存，标记A正在创建中，发现A需要注入B，尝试获取B，进入B的创建流程，实例化B之后，将B放入三级缓存，发现需要注入A，从三级缓存中取出A的ObjectFactory，调用getObject()方法生成A的早期引用，将A从三级缓存移到二级缓存中，A的早期引用注入到B之后，B进入了一级缓存，这个时候就可以从一级缓存中查询到B并且注入到A中。\n\n\n二级缓存不能进行对象的AOP代理，如果二级缓存存放代理对象，就违反了Bean的生命周期。\n\n\n\n\n（2）Bean的生命周期和作用域\n我之前看bilibili视频搞了一个Dog类案例来说明bean生命周期，今天结合面试鸭更系统地总结一下bean的生命周期🎃\n\n\n【说说Bean的生命周期】\nBean的生命周期主要是\n构造函数实例化\n依赖注入\n初始化前的扩展机制（如果Bean实现了BeanNameAware等接口，就进行aware注入）\n初始化前（可以使用BeanPostProcessor接口的前置方法对Bean进行一些额外处理）\n初始化（可以通过init-mothed指定的初始化方法，也可以调用InitializingBean接口的afterPropertiesSet方法）\n初始化后（可以使用BeanPostProcessor接口的后置方法对Bean进行一些额外处理，这个地方主要是实现AOP或者动态代理）\n使用Bean\n销毁Bean（可以通过destory-method属性指定的方法，也可以调用DisposableBean接口的destory方法）\n\n\n【Spring的单例Bean是否有并发安全问题？如何解决？】\n存在并发安全问题，多线程环境下，如果单例Bean包含实例变量或者非线程安全资源，就可能引发线程安全问题。\n解决方案：一是避免在单例Bean中使用可变状态，仅使用线程安全的数据结构，二是使用prototype作用域而不是默认的singleton作用域，每次请求都会创建一个新的Bean实例，避免共享一个Bean实例带来的并发问题。三是通过加锁来管理单例Bean中的共享资源。还可以使用ThreadLocal保存变量。\n\n\n\n\n二. Spring配置方式掌握基于XML配置方式\n熟悉基于注解的配置（如@Configurable，@Component）\n了解基于java配置类的方式\n\n\n三. 面向切面编程（AOP）想想AOP是个啥呢？就是基于动态代理，还有注意有切点和切面，具体的案例我们可以看看之前学习的Spring代码，先看看动态代理吧😁\n\n\n（1）两种动态代理\n我们先弄清楚两种动态代理究竟是啥，打好基础，我们来看看两种动态代理🎃\n\n\n\nJDK动态代理\nJDK动态代理的目标对象必须实现接口，代理对象实际也是这个接口的实现。是由目标对象的类加载器加载的，然后反射生成代理类的实例，反射的过程中就会将InvocationHandler传递给父类的构造方法，所以实例化的代理对象就持有InvocationHandler的引用。\n\n\n依旧是代码辅助理解🎃\n// 接口和实现类public interface UserService &#123;   void save();   void delete();&#125;public class UserServiceImpl implements UserService &#123;   @Override   public void save() &#123;       System.out.println(&quot;主业务逻辑:增加用户管理&quot;);  &#125;   @Override   public void delete() &#123;       System.out.println(&quot;主业务逻辑:删除用户管理&quot;);  &#125;&#125;\n\n// InvocationHandlerpublic class MyInvocationHandler implements InvocationHandler &#123;   private Object obj;   public MyInvocationHandler(Object obj)&#123;       this.obj=obj;  &#125;   @Override   public Object invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123;       System.out.println(&quot;开始监控系统...&quot;);       long t1 = System.currentTimeMillis();//当前时间       try &#123;           Thread.sleep((int) (Math.random() * 2000));      &#125; catch (InterruptedException e) &#123;           e.printStackTrace();      &#125;       Object o = method.invoke(obj, args);       long t2 = System.currentTimeMillis();//当前时间       System.out.println(&quot;结束监控系统...&quot;);       System.out.println(&quot;一共耗费了&quot; + (t2 - t1) + &quot;毫秒&quot;);       //加日志处理       System.out.println(LocalDate.now() + &quot;访问系统&quot;);       return o;  &#125;&#125;\n\n// 生成代理对象public class ProxyUtil &#123;   public static Object getProxy(Object target, InvocationHandler handler)&#123;      return Proxy.newProxyInstance(target.getClass().getClassLoader(),               target.getClass().getInterfaces(), handler);  &#125;&#125;\n\n好，我们生成代理对象，调用方法，就可以看到我们动的手脚了😁\n\n\n\n\nCGLIB动态代理\nCGLIB动态代理是基于继承目标类实现的，主要就是通过实现MethodInterceptor接口定义一个拦截器。\n\n\n依旧是放代码辅助理解😁\n// 定义一个类public class AccountService &#123;   public void save()&#123;       System.out.println(&quot;保存账务管理业务&quot;);  &#125;   public void pay()&#123;       System.out.println(&quot;支持管理业务&quot;);  &#125;&#125;\n\n// 拦截器public class MyInterceptor implements MethodInterceptor &#123;   private Object obj;   public MyInterceptor(Object obj) &#123;       this.obj = obj;  &#125;   @Override   public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;       System.out.println(&quot;进入系统&quot;);       Object invoke = method.invoke(obj, objects);       System.out.println(LocalDate.now());       return invoke;  &#125;&#125;\n\n// 创建代理对象AccountService service = new AccountService();// Proxy.newProxyInstance(classloder,interfaces,invocationhandler);Enhancer enhancer = new Enhancer();enhancer.setClassLoader(AccountService.class.getClassLoader());enhancer.setSuperclass(AccountService.class);enhancer.setCallback(new MyInterceptor(service));// 使用lambda表达式完成处理/* enhancer.setCallback((MethodInterceptor) (o, method, objects,methodProxy) -&gt; &#123;      System.out.println(&quot;开始监控&quot;);      Object invoke = method.invoke(service, objects);      System.out.println(&quot;监控结束&quot;);      System.out.println(LocalDate.now());      return invoke;&#125;);*/AccountService accountService = (AccountService) enhancer.create();\n\n好了，两种动态代理方式总结完毕，接下来就看看AOP吧。\n\n\n\n\n\n\n（2）AOP基本概念和用途\n【什么是AOP？AOP基于哪种动态代理？】\nAOP是面向切面编程，将通用的并且和业务逻辑无关的代码分离开，降低代码的耦合度，避免代码的重复性。主要是由切入点，通知，切面这几个关键概念组成。\nSpring框架根据有无接口来选择是哪种动态代理，SpringBoot2.0开始默认的是CGLIB动态代理。\n\n\n【Spring AOP 和 AspectJ 有什么区别？】\nSpring AOP是主要用于运行时的代理机制，对于非Spring容器管理的类的方法无法代理，而AspectJ是功能更强大的AOP代理框架，支持编译时，类加载时和运行时的AOP功能，使用的范围更广，性能更优。\n\n\n\n\n（3）Spring AOP的配置和实现:\n使用AspectJ进行AOP:\n&lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;   &lt;version&gt;5.3.16&lt;/version&gt;&lt;/dependency&gt;\n\n类的注解加上@Aspect，切点表达式：\nexecution([访问权限类型] &lt;返回值类型&gt;  [包名类名]&lt;方法名(参数列表)&gt;  [异常列表])\n\n现在我们开始看看AOP的具体案例吧，以环绕通知为例：\n@Around(value = &quot;execution(* testUser(..))&quot;)public Object transaction(ProceedingJoinPoint point)&#123;   System.out.println(&quot;开启事务&quot;);   Object res=null;   try &#123;       Object[] args = point.getArgs();       String acc=null;       if (args!=null)&#123;           acc= (String) args[0];      &#125;       if (acc.equals(&quot;12345&quot;)) &#123;           res = point.proceed();//调用目标方法           User u=(User)res;           u.setName(&quot;李四&quot;);           System.out.println(res);      &#125; else           System.out.println(&quot;帐户不存在&quot;);  &#125; catch (Throwable throwable) &#123;       throwable.printStackTrace();  &#125;   System.out.println(&quot;提交事务&quot;);   return res;&#125;// 这里我们注意是要用ProceedingJoinPoint对象获取方法参数和执行方法。// 那要是代理的过程中抛出异常，该咋办？这个时候就可以定义一个异常通知，比如：@AfterThrowing(value = &quot;execution(* showMenu(..))&quot;,throwing = &quot;e&quot;)public void catchException(Exception e)&#123;   System.out.println(&quot;出现了异常&quot;+e.toString());&#125;\n\n\n\n（3）了解常用的切面（事务切面，日志切面）\n\n\n\n\n四. Spring事务管理（1）了解声明式事务和编程式事务的区别\n声明式事务是使用@Transactional注解声明方法的事务边界，在方法执行前自动开启事务，方法结束后自动提交事务。而编程式事务是使用PlatformTransactionManager接口显式地开启，提交和回滚事务。\n\n\n（2）熟悉事务传播行为和隔离级别的配置\n\n\n【说说Spring有哪几种事务传播行为】\n事务传播行为指的是调用方法时是否加入事务，用什么样的事务管理机制。\npropagation_required: 如果存在事务，就用当前事务，如果不存在事务，就新创建一个事务。\npropagation_required_new: 新创建一个事务，如果存在事务，就将事务挂起。\npropagation_supports: 如果存在事务，就用当前事务，如果不存在事务就单独运行。\npropagation_not_supports: 以非事务的方式进行操作，如果存在事务就将事务挂起。\npropagation_never: 以非事务的方式进行操作，如果存在事务就抛出异常。\npropagation_mandatory: 运行当前事务，没有就抛出异常。\npropagation_nested: 存在事务就在嵌套事务内执行，如果不存在事务，就创建一个事务。\n\n\n【事务有哪几种隔离级别】\nisolation_read_uncommitted: 读未提交\nisolation_read_committed: 读已提交\nisolation_repeatable_read: 可重复读\nisolation_serializable: 串行化\nmysql的默认情况就是可重复读。\n\n（3）掌握事务的回滚与异常处理机制\n\n\n我们用一个转账案例来看看事务回滚和异常处理机制😁\n@Servicepublic class AccServiceImpl implements AccService &#123;   @Resource   private AccMapper accMapper;   @Resource   private RecordsMapper recordsMapper;   @Transactional(           propagation = Propagation.REQUIRED,           isolation = Isolation.REPEATABLE_READ,           timeout = 3          /* rollbackFor = &#123;                   FileNotFoundException.class,                   NullPointerException.class           &#125;,           noRollbackFor = &#123;&#125;*/   )   @Override   public void doPay(int money) throws FileNotFoundException &#123;       //存一条交易记录       Records records = new Records();       records.setAccno(&quot;123456&quot;).setCategory(&quot;支出&quot;).setMoney(money);       recordsMapper.insert(records);       System.out.println(&quot;执行交易记录处理&quot;);       //模拟超时处理       try &#123;           TimeUnit.SECONDS.sleep(4);      &#125; catch (InterruptedException e) &#123;           e.printStackTrace();      &#125;       //运行时异常      /* try &#123;           int i = 10 / 0;//算术异常(运行时异常)       &#125;catch(ArithmeticException e)&#123;&#125;*/       //检查型异常      /* if (money &gt; 2000)           throw new FileNotFoundException(&quot;文件找不到异常&quot;);*/       //修改用户原帐户下的余额       Acc acc = new Acc();       acc.setAccno(&quot;123456&quot;);       acc.setMoney(money);       accMapper.update(acc);       System.out.println(&quot;执行用户余额修改处理&quot;);   &#125;&#125;\n\n总结一下：超时和运行时异常默认情况下会回滚，运行时异常被捕捉了，那就不会回滚，检查型异常默认情况下不回滚，如果 rollbackFor 指定了的话，就回滚。\n\n\n\n\n五. Spring模块\n\n（1）SpringMVC\n【说说SpringMVC的执行流程】\n用户发送请求到前端控制器，前端控制器是一个调度中心，前端控制器调用映射器，将用户的请求的url映射到具体的控制器方法，再调用适配器适配到对应的处理器，返回ModelAndView对象到视图解析器解析成视图，最后返回给用户，请求映射到处理器的前后，可以使用拦截器拦截请求。因为现在都是前后端分离，基本没有视图部分了。\n\n\n【SpringMVC的常见注解有那些？】\n@RequestMapping，@GetMapping，@PostMapping映射请求路径，@RequestParam指定请求参数名称，@PathViriable传递路径请求参数，@RequestBody将json格式转化为java对象这些。\n\n\n【说说SpringMVC和Spring WebFlux的区别】\nSpringMVC是同步阻塞，支持传统的JDBC，适合低并发场景，而Spring WebFlux使用的是异步非阻塞，强调的少量线程的高并发方面，资源利用率更好。\n\n\n（2）Spring ORM和Mybatis的集成\n参考热身环节的SSM框架部分。\n\n\n（3）Spring Security配置和使用\n参考之前写的文章SpringSercurity\n\n\n\n\n六. Spring事务监听器\n\n（1）Spring事件驱动模型\n事件驱动模型是定义了对象间的一对多的依赖关系，一个对象的状态发生变化时，所有依赖它的对象得到通知，自动更新。\n\n\n（2）了解自定义事件和事件监听器的实现\n\n\n\n\n七. Spring缓存\n\n（1）了解Spring的缓存抽象与配置\n（2）掌握常用缓存实现（如EhCache, Redis）的集成与使用\n\n\n\n\nSpring Cache是一个可以实现基于注解的缓存功能的框架。\n// 常用注解@EnableCaching  加载启动类上，开启缓存注解功能@Cacheable      查询前看缓存是否有数据，如果有，直接返回，没有，查询后保存到缓存中。@CachePut       方法的返回值放入缓存@CacheEvict     将一条或者多条数据从缓存中删除\n\n\n\n基于redis缓存的代码实例：\n&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;\n\n@PostMapping@CachePut(value = &quot;userCache&quot;, key = &quot;#user.id&quot;)//key的生成：userCache::1public User save(@RequestBody User user)&#123;    userMapper.insert(user);    return user;&#125;\n\n@GetMapping@Cacheable(cacheNames = &quot;userCache&quot;,key=&quot;#id&quot;)public User getById(Long id)&#123;    User user = userMapper.getById(id);    return user;&#125;\n\n@DeleteMapping@CacheEvict(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)//删除某个key对应的缓存数据public void deleteById(Long id)&#123;    userMapper.deleteById(id);&#125;@DeleteMapping(&quot;/delAll&quot;)@CacheEvict(cacheNames = &quot;userCache&quot;,allEntries = true)//删除userCache下所有的缓存数据public void deleteAll()&#123;    userMapper.deleteAll();&#125;\n\n\n\n\n\n八. Spring测试（1）熟悉Spring的测试框架和工具\n（2）数据编写集成测试和单元测试的方法\n\n\nSpring测试主要分为单元测试（单个类或者方法）和集成测试（组件交互是否正确），单元测试可以使用Junit（java标准单元测试框架），集成测试可以使用 @SpringBootTest注解。\n\n\nJunit单元测试:\npublic class MyMathTest &#123;    @Test    public void testAdd() &#123;    MyMath math = new MyMath();    int result = math.add(2, 3);    assertEquals(5, result);    &#125;&#125;\n\n\n\nSpringBootTest集成测试：\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class MyApplicationTests &#123;        @LocalServerPort    private int port;    @Autowired    private TestRestTemplate restTemplate;    @Test    public void testGetUserById() &#123;        String url = &quot;http://localhost:&quot; + port + &quot;/getUserById?id=1&quot;;        ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(url, String.class);        System.out.println(&quot;测试结果为：&quot; + response.getBody());    &#125;&#125;","categories":["java面试"],"tags":["Spring"]},{"title":"面试系列之SpringBoot","url":"/2025/05/11/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E4%B9%8BSpringBoot/","content":"\n\n一. 自动配置原理\n\n（1）理解SpringBoot的自动配置机制\n\n\n【SpringBoot的原理是什么？】\n通过起步依赖和自动配置来实现的，起步依赖包含所需的jar包，有配置类以及提供的Bean，那么就有一个问题了，这些配置类和提供的Bean是如何导入到我们项目中的Spring容器里呢？这个时候就需要自动配置了，起步依赖清楚自己要导入那些配置类和Bean，就将需要的配置类和Bean记录在springboot-autoconfigure这个jar包下的autoConfiguration.import文件中，至于这个文件中的配置类和Bean是如何被发现的？@SpringBootApplication注解封装了一个@EnableAutoConfiguration注解，这个注解又封装了@Import注解，@Import注解的参数就是ImportSelector接口的实现类，实现类的SelectImports实现方法就发现autoConfiguration.import文件，最后导入文件中记录的配置类和Bean就行了。\n\n\n\n\n（2）熟悉SpringBoot Starter的使用和自定义\n\n\nOK, 我们来看看自定义起步依赖aliyun OSS的案例：\naliyun-oss-spring-boot-autoconfigure自动配置:\n\n\n然后aliyun-oss-spring-boot-starter引入其他依赖库和自动配置，进行聚合。\n我们的项目只需依赖aliyun-oss-spring-boot-starter即可。\n\n\n\n\n二. SpringBoot的启动流程\n\n（1）掌握SpringBoot应用的启动过程\n\n\n【说说SpringBoot的启动流程】\n\nmain方法执行\n创建执行启动核心类SpringApplication，判断应用类型，设置初始化器和监听器，确定主应用类\nrun方法：准备应用环境，加载配置文件，创建和刷新Spring容器，启动嵌入式Web服务器，发布已启动事件，执行实现 CommandLineRunner 和 ApplicationRunner 接口的初始化逻辑，发布 ready 事件，应用启动完成。\n\n\n\n（2）理解SpringApplication类的功能与配置\n相当于SpringBoot应用的大脑，可以加载配置文件，实现自动配置，启动嵌入式Web服务器和事件驱动。\n\n\n三. 常用注解与配置\n\n熟悉@SpringBootApplication，@EnableAutoConfiguration等注解的作用\n掌握配置文件的使用与管理\n\n\n四. SpringBoot与Spring集成掌握SpringBoot对Spring框架的增强和简化\n掌握SpringBoot与Spring模块（SpringMVC，Spring Data等）的集成方式\n\n\n\n模块\nStarter 依赖\n功能\n\n\n\nSpring MVC\nspring-boot-starter-web\n集成 Spring MVC 与内嵌 Tomcat。\n\n\nSpring Data JPA\nspring-boot-starter-data-jpa\n集成 JPA + Hibernate + 数据源。\n\n\nSpring Security\nspring-boot-starter-security\n自动配置认证、授权、CSRF 防护等。\n\n\nSpring Batch\nspring-boot-starter-batch\n简化批处理任务配置。\n\n\nSpring AMQP\nspring-boot-starter-amqp\n集成 RabbitMQ 消息队列。\n\n\n\n\n\n\n五. SpringBoot Actuator了解Actuator的功能与使用\nSpringBoot Actuator是SpringBoot提供的一个监控和管理功能的工具。\n熟悉监控与管理端点的配置\n\n\n\n\n六. 其他掌握SpringBoot与Mybatis的集成与使用\n掌握SpringBoot中Spring Security的集成与配置，基本的认证和授权机制\n掌握编写SpringBoot应用的单元测试与集成测试：单元测试@Test，集成测试@SpringBootTest，@Test\nJunit和SpringBootTest都被spring-boot-starter-test这个起步依赖包含。\n","categories":["java面试"],"tags":["SpringBoot"]},{"title":"面试系列之Java基础","url":"/2025/05/12/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E4%B9%8BJava%E5%9F%BA%E7%A1%80/","content":"\n\nε&#x3D;(´ο｀*)))唉，这一部分有点杂乱且多，我总结的时候可以看看之前的课件，做的笔记，再结合面试鸭刷题路线，JavaGuide的自测题。拆解成几部分，逐一攻克。\n\n\n\n\n一. 面向对象编程（1）封装，继承和多态的实现与使用\n\n\n【什么是Java的多态特性】\n多态是指同一个接口或者父类引用变量可以指向不同的对象实例，根据实际指向的对象类型执行相应的方法。\n无需修改原有代码，就可以使用同一方法在不同对象上表现的不同行为。\n\n\n【default，protected，public访问修饰符修饰属性的区别】\ndefault表示只有同包的类才能访问，protected表示同包或者不同包的子类才能访问，public表示同一个模块下，同包和不同包的所有类都能访问。\n\n\n【说说有那些内部类，有什么作用】\nJava内部类指的是在一个类的内部定义的类，有成员内部类，局部内部类，静态内部类和匿名内部类。可以访问外部类的成员变量和方法。主要作用就是简化代码，实现回调函数或者事件监听等事件处理。\n\n\n说到匿名内部类，我们顺便复习一下lambda表达式，看一个代码实例：\n// Runnable接口的匿名实现类new Thread(new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;线程运行中&quot;);    &#125;&#125;).start();\n\n// lambda表达式简化new Thread(() -&gt; System.out.println(&quot;线程运行中&quot;)).start();\n\n这里注意了，Lambda表达式的前提是目标接口是一个函数式接口（只有一个抽象方法的接口）\n\n\n \n\n（2）熟悉抽象类的使用\n\n\n【抽象类和接口有什么区别？】\n在设计动机上有所不同，接口是自上而下的，先定义需要实现那些方法，实现类在进行实现。抽象类是自下而上的，发现了多个类的共同逻辑，将公共逻辑封装成一个抽象类，减少代码冗余。接口可以多继承，抽象类不行，抽象类可以有构造函数和成员变量，接口没有构造函数，成员变量只能是常量。\n\n\n\n\n二. 异常处理\n\n（1）理解异常的分类（检查型异常与非检查型异常）\n检查型异常是编译时检查出来的异常，通常要抛出或者捕捉，不能让编译器抛出来。非检查型异常是包括运行时异常（运行逻辑异常）和错误（严重系统问题，比如内存耗尽和栈溢出）。\n\n\n（2）掌握自定义异常的创建和抛出\n\n\n我们看看两种异常的创建和抛出吧\n\n\n检查型异常（继承Exception类）:throw抛出时必须添加到方法签名或者捕捉。\n// // 示例：用户未找到的检查型异常public class UserNotFoundException extends Exception &#123;    // 提供构造方法传递错误信息    public UserNotFoundException(String message) &#123;        super(message);    &#125;    // 可选：添加自定义字段（如错误码）    private int errorCode;    public UserNotFoundException(String message, int errorCode) &#123;        super(message);        this.errorCode = errorCode;    &#125;&#125;\n\n\n\n非检查型异常（继承RuntimeException类）throw抛出时可以不做任何处理\n\n\n// 示例：年龄无效的非检查型异常public class InvalidAgeException extends RuntimeException &#123;    public InvalidAgeException(String message) &#123;        super(message);    &#125;    // 可选：添加额外逻辑    public String getFixSuggestion() &#123;        return &quot;年龄必须大于 0 且小于 150！&quot;;    &#125;&#125;\n\n\n\n\n\n三. Java内存管理\n\n理解栈与堆的内存分配机制\n熟悉基本的垃圾回收概念\n\n\n\n\n四. 常用Java库\n\n【什么是自动拆箱原理？】\n装箱是使用了包装类的valueOf( )方法，拆箱是调用了比如intValue( )之类的方法。\n\n\n【遇到过自动拆箱导致的空指针异常问题吗？】\n数据库的查询结果中，某个字段为空，映射到的对象的属性为空，如果对这个属性自动拆箱，就会引发空指针异常。\n\n\n掌握常用类库（java.lang，java.util）的使用\n熟悉字符串处理（String，StringBuilder，StringBuffer）\n\n\n【包装类型的常量池技术了解吗】\njava基本类型的包装类大部分都实现了常量池技术。就拿Integer为例，在自动装箱时，对于值在-128到127之间的int类型，会直接返回一个已经缓存的Integer对象，而不是创建新对象。减少内容分配和垃圾回收的负担。\n\n\n【String，StringBuffer和StringBuilder的区别是什么？】\nString是不可变的，适合少量字符串操作\nStringBuffer是可变并且线程安全的，适合多线程环境中的频繁字符串修改。\nStringBuilder是可变并且非线程安全的，适合单线程环境中的高性能字符串处理。\n\n\n【为什么String类型是不可变的？】\n一是字符串常量池会缓存一些字符串对象，多个字符串可以使用一个对象实例，节省内存，但是如果String类型是可变的话，修改字符串会导致其他使用这个字符串的地方出现问题。\n二是多线程环境下，String类型是安全的，不需要担心String被修改的问题。\n三是String类型实现了hashCode方法，String不可变就意味着计算得到的hash值不变，可以保证哈希值的一致性。\n\n\n【重载和重写的区别】\n重载就是同名的方法在不同场景的应用，多个同名的方法通常它们的参数数量以及类型不同。\n重写就是继承父类并且重新实现父类的方法。\n\n\n【深拷贝和浅拷贝了解吗？什么是引用拷贝？】\n浅拷贝创建的对象如果包含引用类型的属性，那这个属性就和原对象对应的属性共用一个内部对象，深拷贝是完全复制整个对象，包括内部对象。\n\n\n\n\n五. 输入输出\n\n（1）理解Java的I&#x2F;O流机制\n（2）熟悉文件的读写操作\nIO流主要分为字节流（InputStream，OutputStream），字符流（Reader，Writer）。\n\n\n【说说文件的读写操作，如何复制文件？】\n\n\n字符流操作文件（不能操作二进制数据，如图片，视频等）\n// FileWriterFileWriter writer = new FileWriter(&quot;d:/aa/hello.txt&quot;);writer.write(&quot;hello world&quot;);writer.write(&quot;\\n&quot;)writer.flush();writer.close();// BufferedWriterFileWriter writer = new FileWriter(&quot;d:/aa/hello.txt&quot;);BufferedWriter bufferedWriter = new BufferedWriter(writer);bufferedWriter.write(&quot;hello world&quot;);bufferedWriter.newLine();bufferedWriter.close();// BufferedWriter 和 FileWriter 的区别：// FileWriter效率低，每次来一个字符要查一次码表，BufferWriter缓存区字符满了之后才会查码表，所以如果频繁地写文件，最好使用BufferedWriter处理。\n\n// FileReaderFileReader reader = new FileReader(&quot;d:/aa/hello.txt&quot;);char[] chars = new char[1024];reader.skip(4);int len = reader.read(chars, 0, 20);String str = new String(chars, 0, len);// BufferedReaderFileReader reader = new FileReader(&quot;d:/aa/hello.txt&quot;);BufferedReader bufferedReader = new BufferedReader(reader);String str;While ((str=bufferedReader.readLine()!=null)) &#123;    System.out.println(str);&#125;bufferedReader.close();\n\n\n\n字节流操作文件：\n// FileInputStream 直接读取原始字节流FileInputStream fis = new FileInputStream(&quot;d:/aa/hello.txt&quot;);while(read = fis.read()!=1)    System.out.println((char)read);fis.close();// BufferedReader 读取字节流转换为字符流之后的结果FileInputStream fis = new FileInputStream(&quot;d:/aa/hello.txt&quot;);InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8);BufferedReader bufferedReader = new BufferedReader(isr);String read;while((read = bufferedReader.readLine())!=null) &#123;    System.out.println(read);&#125;fis.close();\n\n\n\n文件复制：\n// 多个字节复制FileInputStream fis;FileOutputStream fos;byte[] bytes = new byte[1024];int x;while((x = fis.read(bytes))!=-1) &#123;    fos.write(bytes, 0, x);&#125;fis.close();fos.close();// Buffered+多个字节复制// 将fis和fos分别转换为BufferedInputStream和BufferedOutputStream,其他步骤一致// transferTo方法fis.transferTo(fos);\n\n\n\n\n\n【Java的序列化和反序列化是什么？】\nJava的序列化是对象转换为字节流，用于传输，保存到缓存中或者存储到静态文件中。Java的反序列化是将字节流转换为对象的过程。\n代码实例：\npublic class Student implements Seralizable &#123;    private static final long serialVersionUID = 1L;     private String name;    private int age;    // 构造方法    // getter和setter&#125;// 序列化保存到文件FileOutputStream fos = new FileOutputStream(&quot;d:/aa/stu.xxx&quot;)ObjectOutputStream oos = new ObjectOutputStream(fos);oos.writeObject(student);oos.close();// 反序列化FileInputStream fis = new FileInputStream(&quot;d:/aa/stu.xxx&quot;);ObjectInputStream ois = new ObjectInputStream(fis);Stuent student = (Student) ois.readObject();System.out.println(student);ois.close();\n\n\n\n【信息的最小存储单位是字节，为什么需要字符流？】\n字符流封装了编码转换，开发者无需关注底层字节与字符的映射。字符流内部使用缓存区，一次读取多个字节并转换为字符，减少I&#x2F;O操作次数。\n\n\n【BIO，NIO和AIO是什么？】\n分别是阻塞，非阻塞和异步输入输出。BIO是如果要进行I&#x2F;O操作的数据被占用，就阻塞，一直等待。NIO是如果要进行I&#x2F;O的数据被占用，立刻返回，即使操作未完成。AIO是不需要等待操作完成。\n\n\n\n\n六. 反射&amp;注解&amp;泛型\n\n【java反射是什么？有什么优点？】\njava的反射机制是指在运行时获取类的结构信息，比如字段方法等，并且操作对象的一种机制。发射机制提供了在运行时动态创建对象，访问字段和调用方法，无需在编译时知道这些类的具体信息。\n\n\n【谈谈对Java注解的理解，解决了什么问题？】\n注解就是一种提供元数据的机制，可以标记在类，属性和方法上。不影响程序的逻辑执行，可以用反射获取注解的元数据。用在框架里就可以简化配置。\n\n\n【Java泛型的作用是什么？泛型擦除指的是什么？】\nJava泛型作用是通过在编译时检查类型安全，避免在运行时发生类型转换的错误。另外，泛型还能使代码适用于多种不同类型，减少代码重复。\n泛型擦除指的是Java编译器在编译时擦除泛型信息，用合适的类来代替泛型类型的参数，通常情况下会用对象的上限来代替这些类型的参数，如果没有指定上限，默认用Object代替。\n\n\n【Java泛型有那些限制？】\nJava泛型的上下界限定符用于对于泛型类型参数进行范围限制，上界限定符（? extends T）表示通配符只能是T类型或者T的子类，通常用于读取操作，下界限定符（? super T）表示通配符只能是T类型或者T类型的父类，通常用于写入操作。\n\n\n\n\n六. 基础多线程\n\n理解线程的创建与启动方式\n掌握基本的线程生命周期管理\n\n\n\n\n七. 基础设计模式\n\n（1）了解基础设计模式\n（2）理解设计模式的适用场景 \n单例模式（饿汉式，懒汉式）\n工厂模式\n\n\n\n\n八. SPI这一部分为进阶，之后在做。\n","categories":["java面试"],"tags":["Java基础"]},{"title":"面试系列之MySQL","url":"/2025/05/04/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E4%B9%8BMySQL/","content":"一. MySQL架构\n\nMySQL架构共有4层，由上到下分别为连接层，服务层，引擎层和存储层。连接层负责访问校验和授权，服务层负责sql语句的分析，优化以及查询数据的缓存，引擎层负责数据的存取以及索引的创建，存储层负责将数据存储到文件系统上。\n\n\n【一条sql语句在MySQL中是如何执行的？】\n首先到连接器验证身份并授权，然后查询缓存，若有相应数据，直接返回，若没有，则使用分析器对SQL语句进行语法分析和词法分析，再使用优化器对SQL语句进行优化，到执行器检查sql语句是否有相应权限，如果有就调用存储引擎执行sql语句，返回数据并且保存到缓存中。\n\n\n【MySQL有那些存储引擎，它们之间有什么区别？】\nMySQL主要的存储引擎是 MyISAM 和 InnoDB。\n区别：\n\nInnoDB的文件结构为 .frm 文件（每个表都有的元数据文件），ibd 文件（独享表空间存储方式，每个表都有一个）或者 ibdata文件（共享表空间存储方式，只有一个），MyISAM的文件结构为 .frm 文件，.MYD文件（存放数据），.MYI文件（存放索引）。\n\nInnoDB支持事务和外键，是聚簇索引，MyISAM不支持事务和外键，是非聚簇索引。\n\nInnoDB最小的锁粒度是行锁，MyISAM的最小锁粒度是表锁，后者一条更新语句就会锁着整张表，其他查询更新语句就会阻塞，导致性能较差。\n\n\n\n\n【MySQL字符串类型有那些？char，varchar有什么区别？】\n字符串类型有：char, varchar, blob, text, set, enum\nchar是固定长度，最多存储255字节，varchar是根据实际字符所占字节再加1或2，这1或者2个字节是存储长度。超过char或者varchar的最大长度限制的字符串会被截断。\n\n\n\n\n二. 索引索引是帮助MySQL高效获取数据的方式，可以理解为排好序的快速查找的数据结构。\n不同的存储引擎的索引机制不同。InnoDB的索引和MyISAM的索引都是用B+树来实现的。InnoDB是聚簇索引，索引和数据在一个B+树上，每个节点都是一个磁盘块，非叶子节点存储索引，叶子节点存储数据。而MyISAM是非聚簇索引，非叶子节点存储索引，叶子节点存储的是数据的内存地址。\n\n\n【MySQL索引的底层实现为什么不用B-树，为什么不用Hash？】\nB-树和B+树的区别在于，B-树的所有节点都可以存储数据，每个节点都是一个磁盘块，大小固定，当非叶子节点中的数据较大时，它能存储的索引数量就较少，那么整个B-树要想和B+树存储相同大小的数据，高度就更大，这个时候要想查找和操作数据的话，磁盘的IO次数就增多，就降低查询和操作数据的效率。\nHash实现索引就是用hash算法将数据库字段数据转换为定长的Hash值，与这条数据的行指针一起存储到hash表中。存在hash碰撞，通过链表或者一些定长寻址法，平方寻址法解决，只能进行等值查询，不能进行顺序查询和区间查询，查询效率比较低。\n\n\n【如何根据辅助索引查找数据？】\n依旧是B+树实现，辅助索引在非叶子节点并且根据ASCII码进行排序，叶子节点存储主键，根据辅助索引查找到主键之后，再通过主键进行回表查询。\n\n\nInnoDB索引结构要注意主键占用的存储空间尽量小一点，便于存储索引和比较大小\n\n\n【覆盖索引是什么？】\n覆盖索引是查询时select的字段被索引包含，通过查找索引就能快速查找到所需的数据，不一定要到叶子节点找到整行数据。MySQL查询优化器在查询前就会判断是否存在覆盖索引的情况。\n\n\n\n\n三. MySQL查询\n\nsql查询语句：\nSELECT DISTINCT &lt;select_list&gt;FROM  &lt;left_table&gt; &lt;join_type&gt;JOIN  &lt;right_table&gt; ON &lt;join_condition&gt;WHERE  &lt;where_condition&gt;GROUP BY  &lt;group_by_list&gt;HAVING &lt;having_condition&gt;ORDER BY &lt;order_by_condition&gt;LIMIT &lt;limit_number&gt;\n\n\n\n【联合查询Join有那些类型，不同类型有什么区别？】\nLEFT JOIN: 左表所有数据 + 符合条件的联合查询数据RIGTH JOIN: 右表所有数据 + 符合条件的联合查询数据INNER JOIN: 符合条件的联合查询数据\n\n\n\n\n\n四. 事务\n\n（1）事务的基本要素 ACID原子性：整个事务中的所有操作，要么全部完成，要么全部不完成。\n一致性：事务的开始之前，事务结束之后，数据库的完整性约束没有被破坏。\n隔离性：一个事务的执行不能其它事务干扰。\n持久性：事务完成时被更改的数据持久地报错在数据库中。\n\n\n【说说事务的四大特性和实现原理】\n事务的四大特性分别是原子性，一致性，隔离性和持久性。原子性，一致性和持久性是通过事务日志来实现，隔离性是通过锁来实现。\n事务日志分为重做日志redo和回滚日志undo，在事务启动之前，将事务放入存储引擎的日志缓冲里，在事务提交前将日志缓冲刷新到重做日志redo里，事务提交之后，在Buffer Pool中映射的数据文件会在后台慢慢地刷新到磁盘数据文件中，实现数据的持久性。如果事务执行的过程中出现异常或者数据库宕机，那就可以通过重做日志redo恢复到该事务执行前的数据状态，或者继续提交，保障了事务的原子性。而回滚日志undo会记录数据操作之前的状态，事务执行过程或者出现异常的情况需要回滚的话，就可以根据回滚日志进行回滚，保障了数据的一致性。\n？隔离性是可以通过设置事务隔离级别和锁来实现\n\n\n\n\n（2）并发事务引发的问题和隔离级别\n\n【事务并发引发那些问题，针对这些问题有那些隔离级别？】\n\n\n并发事务引发问题：\n脏读：事务A读取了事务B更新的数据，事务B回滚，这个时候，事务A读到的数据就是脏数据。\n不可重复读：事务A多次读取同一数据，事务B在事务A读取的过程中，对该数据进行更新，导致A前后读取的数据不一致。\n幻读：事务A多次读取几行数据，事务B在事务A读取的过程中插入数据，那事务A就会读取到原本没有的数据，好像发生了幻觉。\n\n\n不可重复读和幻读的区别在于前者的着重点在于数据被修改，后者在于数据的数量变多了或者变少了。\n\n\n那么为了应对以上的问题，需要设置隔离级别：\nRead-uncommitted: 允许读取尚未提交的数据变更。会导致脏读，不可重复读和幻读。\nRead-committed: 允许读取并发事务中已经提交的数据。避免脏读，会导致 不可重复读和幻读。\nRepeatable-read: 读取已经提交的数据，并保证前后读取数据的一致性。避免脏读和不可重复读，但还可能有幻读。\nSerialiazable: 事务逐个进行，避免并发事物的所有问题。\n\n\n隔离级别越高，并发性越差，InnoDB存储引擎的默认事务隔离级别是Repeatable-read，保留了比较好的并发性，还使用了Next-Key Lock算法避免了出现幻读的情况。\n\n\n\n\n（3）多版本并发控制MVCC【了解MVCC吗，说说它的底层原理】\n\n\nMVCC的实现是通过保存数据在某个时间点的快照来实现的，每个事务看到的数据都是相同的，可以减少并发锁的添加。\n\n\n可以以InnoDB存储引擎为例，讨论MVCC是如何工作的。通过在每行记录的后面保存两个隐藏列，分别为行版本号和行删除标识，前者表示创建或者修改的时间，后者表示删除的时间。当查询数据时，就会将当前的时间和前面两个时间做比较，当前的时间也就是查询的时间要在新增或修改的时间之后，在删除的时间之前。保证了查询的是有效数据并且避免不可重复读和幻读。\n\n\n\n\n（4）事务日志【事务日志有什么优点？】\nInnoDB使用日志来减少提交事务时的开销。事务修改的数据和索引要映射到表空间中的随机位置，需要很多IO，开销比较大，还容易丢失数据。就可以在事务提交之前将事务记录到事务日志文件并持久化到磁盘，事务日志文件的记录是追加形式的，就是顺序IO，还能提高读取性能，这样就不怕数据丢失了，那修改的数据和索引就可以在后台慢慢持久化到磁盘数据里了。\n\n\n\n\n五. MySQL锁机制\n\nMySQL锁主要分为共享锁（读锁，同一份数据被不同事务同时读取）和排他锁（写锁，进当前事务可读写，其他事务不能）\nInnoDB有表锁和行锁（默认用行锁，索引失效则转为表锁），MyISAM只有表锁。\n\n\n【什么是乐观锁和悲观锁，InnoDB的行锁是如何实现的？】\n乐观锁是在访问和处理数据前不加锁，只有在更新数据时根据版本号或时间戳判断是否有冲突，有则处理，没有就提交事务。悲观锁是在访问或处理数据前加排他锁，事务提交或者回滚就释放锁。\nInnoDB有三种行锁的算法，第一种是记录锁，对单个行的索引加锁，其他事务不能修改和删除加锁项。第二种是间隙锁，就是索引范围查询时，将该区间锁住（不包括首尾索引），不能插入删除和修改该区间的命令将被阻塞，可以避免幻读。第三种是临键锁，是记录锁和间隙锁的组合，只存在与非唯一索引项，当事务查询该索引区间时会锁住左开右闭的区间数据。\n\n\n【死锁是怎么产生的，如何解决死锁？】\n两个或者多个事务在同一资源上互相占用，并且请求锁定对方的占用的资源导致恶性循环，产生死锁。\nInnoDB目前解决死锁的方法是将最少行级排他锁的事务进行回滚，然后大多数情况下，再重新执行回滚的事务既可。\n当涉及表锁时InnoDB不能完全自动检测死锁，则个时候就可以设置超时等待参数 innodb_lock_wait_timeout 来解决。\n\n\n【innoDB是如何避免死锁的？】\n","categories":["java面试"],"tags":["mysql"]},{"title":"面试系列之redis","url":"/2025/04/28/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E4%B9%8BRedis/","content":"介绍：redis是一种无关系型数据库，在项目和面试中经常提及，正好开始系统地学redis了，今天我们就以总结的方式开始java面试之redis篇。\n\n\n\n\n一. 持久化\n\n（1）Redis AOF介绍： AOF(append only file) 是一种只记录写操作的日志，redis先执行命令再记录日志，redis不会检查日志，如果.aof日志出现问题的话，通常可以用redis-check-aof 命令进行修复。\n\n\n\nAOF三种写回策略\n在redis执行一个写命令完成后，就记录写日志，这样对redis的性能会有较大的影响，另外如果还没来得及记录记日志，系统就宕机了，会导致数据永久性丢失的问题。为了解决以上两种问题，引入了AOF三种写回策略：\n\n\nalways: 同步写回everysec: 将日志写入aof日志缓冲区，每隔一秒写入磁盘文件中no: 将日志写入aof日志缓冲区，由操作系统决定什么时候写入磁盘文件中\n\n\n\n以上三种策略 no的性能最好，但是可能大量丢失数据。 always大概率不会丢失数据，但性能较差，所以通常会这种采取everysec策略。\n\n\nAOF重写机制\n随着写操作的数量增多，占用磁盘空间增大，为节省磁盘空间，可以采用AOF重写，即读取redis现有的数据，根据数据创建写操作的日志。可以使用命令 bgrewriteaof, 可以在redis.conf中配置重写的临界条件：\nauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb\n\n\n\n了解了重写的目的之后，我们可以看看重写的流程：\nbgrewriteaof 命令进行重写，如果当前有重写正在进行就等待，如果没有，就创建一个子进程，这样就不会对主进程造成阻塞，子进程循环遍历redis内存数据到临时文件，在此期间，客户端的写请求会记录到aof缓冲区和aof重写区，确保原aof文件的完整和新的aof文件生成期间不会漏掉增添修改操作，子进程写完新的aof文件后向主进程发送请求，主进程接收请求后aof重写缓冲区的数据写入新的aof文件并且覆盖掉旧的aof文件。\n\n\n（2）Redis RDBRDB(Redis Database)是一种内存快照，记录内存某一时刻的数据状态。使用命令bgsave，即在主进程外又创建一个子进程，由这个子进程来完成RDB快照，假如内存快照有6GB的内存数据量，需要5s的时间来完成RDB文件的写入，那么在这5s内，仍旧需要将这个时间段内的添加和修改数据的操作写入到RDB文件中，这个时候就用到写时复制技术，对于增添修改操作是通过复制一个副本，子进程再执行，所以子进程是一边写快照，一遍执行主进程的操作，从而防止快照导入RDB文件时数据的丢失。\n\n\n（3）混合AOF和RDBredis.conf中打开aof，打开混合配置\nset k1 v1set k2 v2set k3 v3bgrewriteaofset k4 v4set k5 v5\n\n以上的执行结果是前三次操作后的RDB快照是aof文件的前一部分，后两个操作是aof文件的后一部分。\n如果数据不能丢失，使用AOF和RDB混合是一个好的选择。\n\n\n二. 主从复制\n\n简单点说，就是主从库采用读写分离的方式，主库进行写操作并将数据同步给从库，从库只能进行读操作。\n这样来提升读取的性能。\n\n\n主从同步原理：\n第一阶段： 从库执行 replicaof 命令，主从库建立连接，从库向主库发送psync指令，主库返回给从库唯一标识runID和复制进度offset。\n第二阶段：主库向从库发送rdb文件，从库接收并加载rdb文件\n第三阶段： 将replication buffer内的数据（即rdb文件生成之后执行的写操作）发送给从库，从库接收并加载。\n\n\n\n上面介绍了主从同步部分，那如果只有一个主库的话，从库多了，主库同步给从库的压力就会增大。这个时候就用到主从从模式了，即在主从模式的基础上，从库不在replicaof到主库，而是replicaof到其他从库，从而让从库分担数据同步的压力。\n\n\n还有一个问题，如果同步过程中网络异常，再次连接导致数据丢失怎么办？redis采用repl_backlog_buffer缓冲区记录主库写到的位置和从库读到的位置。这样再次连接时，如果从库读到的位置落后于主库写到的位置，就会从库继续读取直至与后者相同。\n缓冲空间大小&#x3D;主库写入速度 * 操作大小-主从库网络传输速度 * 操作大小\nrepl_backlog_size&#x3D;缓冲空间大小*2\n\n\n\n\n三. 哨兵模式\n\n下面是比较简单的哨兵集群的效果图：\n\n\n\n\n我们在虚拟机的centos这一个操作系统模拟哨兵集群： 用redis-server来启动不同接口的redis服务，设置一主二从的关系，在以redis-sentinel启动三个哨兵，哨兵的配置如下：\n// 端口port 26379// 监视  格式：sentinel monitor &lt;自定义的reids主节点名称&gt; &lt;IP&gt; &lt;port&gt; &lt;数量&gt;sentinel monitor mymaster 127.0.0.1 6379 1// 主节点多少毫秒未应答，则下线sentinel down-after-milliseconds mymaster 30000\n\n\n\n（1） 联系好，现在基本的服务都启动了，那么有一个问题，每个哨兵都监视主库，那哨兵是如何知道彼此的？哨兵又是如何监视从库的？\n\n是通过redis的pub&#x2F;sub发布订阅机制实现哨兵的联系，主库master有一条_sentinel__:hello的专用通道，用于哨兵之间订阅发送消息。就好像是master建了一个微信群，哨兵可以发送消息，可以看到其他哨兵的消息。\n\n哨兵向主库master发送info命令，主库将从库列表返回给哨兵，哨兵和从库建立和从库建立连接，监视从库。\n\n\n（2）运行介绍完联系之后看看如果主库宕机，哨兵集群如何判断主库宕机的？是如何选取新的主库的？\n判断主库宕机和选取新的主库的过程都设计到哨兵少数服从多数的原则，所以哨兵的数量应该是奇数更合适，主库被哨兵集群监控，多数哨兵判断主库下线了，那认为主库宕机了，这个时候要选取新的主库，那由那个哨兵来进行呢，这个时候依旧是少数服从多数，得到多数投票的那个哨兵来选取新的主库，选取新的主库有三个筛选条件，一是选取每个从库配置中优先级最大的那个，这通常意味着这个从库的配置更高，内存更大。二是选取repl_backlog_buffer缓冲区中和主库写操作的位置最接近的那个从库。三是每个redis实例都有一个id,选择id最小的。\n\n\n\n\n\n\n四. 分片集群\n\n（1）配置我们依旧在同一个虚拟主机完成，redis-server启动六个接口的redis服务, 配置文件如下：\ninclude redis.confpidfile &quot;/var/run/redis_6379.pid&quot;port 6379dbfilename &quot;dump6379.rdb&quot;# 打开集群模式cluster-enabled yes# 设定节点配置文件cluster-config-file nodes-6379.conf# 设置节点失联时间，超过，会自动进行主从切换cluster-node-timeout 15000\n\n修改redis.conf文件：\nbind 127.0.0.1 192.168.230.30(虚拟主机ip)\n\n六个服务启动\n六个服务合成一个集群：\nredis-cli --cluster create --cluster-replicas 1 192.168.230.30:6379192.168.230.30:6380 192.168.230.30:6381 192.168.230.30:6579 192.168.230.30:6580192.168.230.30:6581// --cluster create: hash slot平均分配到实例中// --cluster-replicas 1: 主从比例1:1\n\n\n\n（2）原理以及常用命令一个分片集群有16384个槽，我们向集群中存储键值对的时候，根据键值对的key, 按照CRC16算法计算出一个16bit的值，用这个值对16384取模运算，得到的数代表对应的编号的哈希槽hash slot。\n\n\nredis-cli -c -p 6379// 四大数据类型，bitmap,HyperLogLog 操作cluster nodes // 显示集群各个节点信息cluster keyslot &lt;key&gt;cluster countkeyinslot &lt;slot&gt;cluster getkeysinslot &lt;slot&gt; &lt;count&gt;\n\n\n\n因为主从比例为1:1，所以如果其中一个节点的主库宕机，从库就会接手，当如果该节点主从库全部宕机的话，默认整个集群都挂掉。默认配置：\ncluster-require-full-coverage yes\n\n如果配置为no的话，只有该节点不可存取数据，整个集群不会挂掉。\n\n\n\n\n五. Geospatial\n\n通常用于表示坐标相关数据，可以计算坐标距离呀，一个坐标范围内的其他坐标呀，可以看做是redis第六种数据结构了，基于zset有序集合，值得注意的是它的分数是由坐标计算而来。\n\n\n（1）geo原理geo是如何根据坐标计算分数的？答案便是GEOHash编码，将经纬度分别进行编码，再交叉合并，合并的值作为geo元素的权重。  \n\n\n\n经纬度编码：做N次二分区，比如经度为135，做第一次二分区，判断是位于[-180, 0)还是[0, 180], 左分区用0表示，右分区用1表示，135位于右分区，用1表示，所以最后获得了N位0或1组成的编码。\n\n交叉合并: 合并的结果第一位是经度编码的第一位，结果的第二位是纬度编码的第一位，就这样经纬度交叉进行。\n\n\n（2）geo应用\n计算两个位置的距离\ngeodist key member1 member2\n\n\n\n获取附近的geo元素\n如获取距离自己500m以内的女神姓名：\ngeoradius key 自己位置信息 500 m [ASC|DESC] [count number]\n\n可以理解为将二维位置映射到一维的线上，距离较近的两个点，实际距离也是比较近的。\n\n\n\n\n六. 事务\n\nredis事务分为原子性，一致性，隔离性和持久性。\n\n\n\n原子性：事务中所有的指令要么都执行，要么都不执行。\n可以根据错误的发生时机分为EXEC命令执行前报错，执行时发生故障，执行后报错这三种情况来讨论，在错误命令入队时，redis就会报错并记录这个错误，其他命令还能接着入队，到执行EXEC命令时，就会报错，整个事务就不能执行。如果EXEC命令执行前没报错，执行时发生故障，只有部分事务记录到AOF日志文件中，这个时候就可以使用redis-check-aof工具将未完成的事务从日志中删除，从而保证原子性。如果前两者都没问题，到了执行后报错，那这个时候大多数都是事务中执行的指令一般都和操作类型不匹配才导致报错，正确的指令能执行，错误的指令无法执行，因为redis不支持回滚，所以这个时候就无法保证原子性了。\n\n\n一致性：事务执行前后，数据库状态保持一致，符合预期的规则和约束，比如说主外键关联，完整性约束等一些数据库内部规则不能被破坏。\n执行前，入队报错，事务不执行，能确保一致性。执行时故障，一致性和数据恢复方式有关：如果只开启RDB快照，事务操作的结果没有被保存到快照中，实例重启时，数据是一致的。如果开启了RDB和AOF日志，部分操作被记录到AOF日志中，可以使用redis-check-aof清除事务中已经完成的操作保证事务的原子性，从而保证了一致性。如果EXEC命令执行后报错，正确的指令已经执行，错误的指令没有执行，可以保证一致性。\n\n\n隔离性：多个事务并行执行时，互不干扰。\n并发操作在EXEC命令执行前执行，需要通过WATCH机制进行保证，WATCH机制的作用是监视该事务操作的一个或多个键是否被其他事务修改，如果被修改，就放弃执行该事务从而保证事务的隔离性。并发操作在EXEC命令执行后执行不会破坏事务的隔离性，因为redis使用单线程执行命令，而且执行完命令，它还会保证前一个事务的所有命令执行完之后才会执行之后的事务。\n\n\n持久性：\n没有使用RDB和AOF，数据丢失\n只使用RDB快照，那么在事务执行之后，快照执行之前发生宕机，也会数据丢失，采用了RDB和AOF，AOF的三种配置选项no, everysec和always也会出现数据丢失的情况，所以事务的持久性不能保证。\n\n\n\n\nredis的事务可以保证一致性和隔离性，具备一定的原子性但不支持回滚，无法保证持久性。\n\n\n\n\n七. 缓存redis缓存属于旁路型缓存，一般有两种情况：缓存命中和缓存缺失，两种类型：只读缓存和读写缓存。\n读取数据时如果缓存命中，直接返回，如果缓存缺失，向数据库访问，并刷新缓存。向缓存写数据时，缓存将数据刷新给数据库时可以同步直写，也可以异步写回。\n\n\n（1）缓存数据的删除\n删除策略\n\n缓存数据的删除大多情况下都是过期数据的删除，redis中删除过期数据有两种策略：惰性删除和定期删除。惰性删除是数据过期了，当再次访问该数据时使用内部函数expirelfNeeded进行判断，如果过期，进行删除，节约CPU资源但内存占用大。定期删除是每隔一段时间调用函数抽取20个key进行检测，删除过期的key，如果过期的key的数量大于25%，那就循环执行，最多执行N次，这个N是可以设置的。\n\n\n\n淘汰策略\n\n那么当缓存的数据超过缓存的容量时，该如何是好？这个时候就要用到逐出算法了，制定缓存淘汰策略。\n\n\n针对过期数据的淘汰策略有四种：\nvalotile-ttl : 按照过期时间的先后顺序删除\nvalotile-random: 随机删除\nvalotile-lru: 使用LRU算法筛选过期的键值对删除\nvalotile-lfu: 使用LFU算法筛选过期的键值对删除\n\n\n针对所有数据有三种：allkeys-random   allkeys-lru   allkeys-lfu\n\n\nLRU算法是将最近不用的数据筛选出来。需要维护一个链表来管理所有的缓存数据，数据被访问时，执行链表数据的移动，利用链表的顺序筛序出N个数据，再将最小的数据淘汰。\nLFU算法是将使用频率最小的数据筛选出来。每个数据块都有一个引用计数，维护一个队列将数据块进行排序，淘汰数据时，把队列尾部的数据块删除。\n\n\n过期数据淘汰是根据具体情况选用，所有数据淘汰一般情况下用allkeys-lru策略，如果数据的使用频率相差不大，也可以用allkeys-random策略。\n\n\n（2）缓存异常\n数据不一致：\n就是数据更新，读取到的依然是旧值。通常是由两种情况导致，一种是缓存删除了，但是数据更新失败，一种是数据更新成功，但是缓存删除失败。\n解决方案：就是利用重试机制，把要删除的缓存值或者更新数据库值先存储到消息队列中，出现数据不一致，就重试。\n\n\n如果是多线程访问，分为两种情况讨论，如果是先删除缓存，后更新数据，那么一个缓存在执行到数据更新的过程中，另一个线程访问数据拿到的依然是旧值，并且还会刷新缓存，就下来的其他所有线程拿到的都是旧数据。为了避免后续的线程拿到的都是旧数据，就会用到延迟双删，这个延迟双删其实就是线程执行完删除缓存和更新数据之后，休眠一段时间，休眠结束就再次删除缓存，这样之后的其他线程访问数据时，拿到的就是新值。如果是第二种情况，先更新数据，再删除缓存，那么在线程更新数据这一时间内，其他线程拿到的是旧数据，更新并且删除缓存完成后的其他线程拿到的是新数据。\n\n\n\n\n缓存击穿\n要读取的数据在数据库中存在，在缓存中已经过期，从数据库读取的数据刷新到缓存中，这种情况叫做缓存击穿。\n\n\n那么如果大量数据同时过期，这些数据又同时被访问，那么就会对数据库造成较大压力。\n解决方案：\n对于热点数据不设置过期值，或者对于在设置过期时间的时候再加上一个随机时间，让过期时间不同，避免同时过期。至于不同时过期的情况，可以使用redis删除过期数据两种策略之一的定期删除。也可以采用预热的方式，即将热门数据提前存入缓存。还可以使用锁，缓存失效时，不是直接访问数据库，而是只有获取一个分布式锁才能访问数据库，如果不能获取分布式锁，说明已经有线程在执行，这个时候就休眠一段时间，在去获取分布式锁。\n\n\n\n\n缓存穿透\n要读取的数据在缓存中没有，在数据库中也没有。每次都会穿透到数据库，缓存成了摆设，增大数据库的压力。\n\n\n解决方案：\n可以设立缺省值，发现缓存穿透的数据就设立一个缺省值，后续访问时返回空值。\n还可以用布隆过滤器，就是数据写入数据库时，将数据的 id 存入布隆过滤器中， 读取数据时在过滤器中查找数据 id ，如果没有就不会到数据库中查询。布隆过滤器的算法就是维护一个bit类型的数组，写入数据 id ，使用三个hash函数，一个id映射到三个位置并存入1，查询 id，如果这个id映射的三个位置有0，那么id不存在。所以布隆过滤器判断id存在时，id可能存在，判断id不存在时，id就不可能存在。\n\n\n\n\n缓存雪崩\n大量请求无法在缓存中处理，全部打到数据库中致使数据库压力剧增甚至宕机。一个redis实例支持10万的QPS，而一个数据库实例一般只有1000QPS。和缓存击穿相似的一点是缓存都无效，区别于缓存击穿的一点是缓存雪崩是大量数据同时失效，缓存击穿是某个热点数据失效。有两种情况：大量数据同时过期，redis宕机\n\n\n解决方案：\n设置过期时间时再加上一个随机时间，防止大量数据同时过期。也可以进行接口限流，减小数据库压力。\n对于redis宕机引发的缓存雪崩的解决方案是：限流和服务熔断。服务熔断指的是从缓存获取数据异常就直接返回错误给前端，防止打到数据库。当然，最好的方法就是构建高可用的缓存集群，主库宕机，从库接替主库。\n\n\n\n\n八. jedis\n\nspringbot 引入 jedis 依赖包，利用 Jedis 对象来连接redis和操作redis数据。\n\n\n这里讲讲 redis 五大基本数据类型，geo的常用命令，增删改查的顺序：\n\n\n（1）redis 五大基本数据类型\nString: [set, setnx, setex, setrange, mset, msetnx]  [unlink, del] [append, incr, decr, incrby, decrby] [get, mget, getrange, substr, strlen]\nList(双向链表): [lpush, rpush, lpushx, linsert]  [lpop, rpop, lrem, brpop]  [lset]  [lrange, lindex, llen]\nHash: [hset, hsetnx, ]  [hdel]  [hincrby, hincrbyfloat]  [hget, hmget, hgetall, hexists, hkeys,hvals,hlen]\nSet: [sadd, ]  [spop, srem, smove ]  []  [amembers, sismember, scard, srandmember, sinter, sunion, sdiff, sinterstore]\nzset: [zadd]  [zrem]  [zincrby]  [zrange, zrevrange, zrangebyscore, zrevrangebyscore, zrangebylex, zcard, zcount, zrank, zscore]\n\n\n\n（2）geogeoadd &lt; key&gt; &lt; longitude&gt;&lt; latitude&gt;&lt; member&gt;\ngeopos &lt; key&gt;&lt; member&gt; [&lt; member&gt;…]\ngeodist &lt; key&gt;&lt; member1&gt;&lt; member2&gt;\ngeoradius &lt; key&gt;&lt; longitude&gt; &lt; latitue&gt; radius [m | km| fm| mi] count number\n","categories":["java面试"],"tags":["redis"]},{"title":"面试系列之Java集合","url":"/2025/05/13/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E4%B9%8BJava%E9%9B%86%E5%90%88/","content":"\n\n今天也是进入Java集合的面试总结了，明天就开始搞JUC和JVM了，搞完了八股文系列就完结了，之后再去投简历，同时继续学习微服务。也是被我安排的明明白白的🎃。\n\n\n老规矩，先放大概图：\n\n\n\n\n\n\n昨天晚上和今天上午看了HashMap大概和put流程以及put源码，现在先总结一下HashMap的这几部分，之后再继续看看HashMap的扩容源码。\n\n\n一. HashMap\n\n【说说HashMap的实现原理？】\nHashMap底层采用数组加链表和红黑树。\n当我们向HashMap中存入对象时，由key对象经过hash方法（获取hashCode值，右移16位 和原来的hashCode值做异或运算），再和桶数组的长度取余，计算出索引，再将key和value封装成Entry对象，存入对应索引位置。如果对应索引已经存在Entry对象，就将该对象的key和要存入的key比较，相等的话就直接覆盖，不相等的话就将当前的Entry对象添加到链表或者红黑树中。\n\n\n【HashMap的jdk1.7和jdk1.8有什么区别？】\njdk1.7采用的是拉链法，就是数组和链表结合，发生冲突时将冲突的值放入链表中。jdk1.8在解决哈希冲突方面加入了红黑树的解决方法，当链表的长度大于8，数组的长度达到64时，将链表转化为红黑树，当扩容后，红黑树的节点数量小于等于6时，就退化成链表。\n\n\n【HashMap的put方法的具体流程】\nHashMap是采用懒惰加载的方式，第一次使用put方法时，会初始化成默认的64大小容量的桶数组。从Key对象计算出索引后，看指定索引位置是否有Entry对象，没有的话就直接插入，进入扩容的逻辑，如果有的话，判断Entry对象的key是否相同，相同的话就直接覆盖，然后结束。不同的话判断是否为红黑树，是红黑树就添加到红黑树中，不是的话，就循环链表判断是够存在key相同，存在就直接覆盖，不存在的话就添加到链表中，如果满足转换为红黑树的条件，就转化为红黑树，最后进入扩容的逻辑。\n\n\n【说说HashMap的扩容机制】\n在初始化和添加元素的时候都需要调用resize方法扩容，第一次添加数据初始化数组的长度为16，之后每次扩容都是元素数量到达扩容阈值，扩容后会创建一个新的数组，容量和扩容阈值都是原来的两倍，把原来数组的数据挪到新的数组中，没有hash冲突的节点，直接用hash值与newCap-1取余的结果计算索引并存储，有hash冲突的节点，如果是红黑树，就走红黑树的添加，如果是链表，就遍历拆分链表，计算节点的hash值和(newCap-1)的与运算的结果，如果为0，就停留在原位置，否则移动到原始位置+增加的数组大小这个位置上。\n\n\n【为何HashMap的数组长度一定是2的次幂？】\n2的n次幂可以使用位与运算代替取模，计算索引的效率更高。扩容时重新计算索引的效率也更高，hash&amp;oldCap&#x3D;&#x3D;0,元素留在原来位置，否则新位置&#x3D;旧位置+oldCap。\n\n\n【HashSet和HashMap有什么区别？】\nHashSet实现了Set接口，只存储对象，HashMap实现了Map接口，存储的是键值对。HashSet底层是用HashMap实现存储的，封装了一系列HashMap的方法，value默认就是Object对象，HashSet不允许出现重复值。\n\n\n【HashTable与HashMap的区别】\nHashTable是数组+链表，hash算法就是key的hashCode值（HashMap是二次hash），是线程安全的（hashMap是非线程安全的），但是实际开发中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类。\n\n\n\n\n二. List\n\n【说说Java提供的常见集合？】\nJava集合主要分为Collection单列集合和Map双列集合。Collection中有List和Set接口，平时使用较多的有ArrayList和LinkedList，Map中常见的实现类有HashMap，TreeMap，线程安全的ConcurrentHashMap。\n\n\n【ArrayList底层是如何实现的？】\n我主要说说add方法吧，为了确保数组的size+1之后足够存下下一个数据，计算出数组的容量，如果当前数组的size+1大于长度，就调用grow方法扩容到1.5倍，确保新增的数据有地方存储之后再添加新元素。\n\n\n【如何实现数组和List之间的转换？转换前后有什么关系？】\n数组转list是调用Arrays.asList方法，转化之后的List是对数组的包装，数组改变，List也跟着改变，List转数组是调用toArray方法，是对List底层数组的拷贝，修改了List，数组不会改变。\n\n\n【ArrayList和LinkedList的区别是什么？】\nArrayList是动态数组，LinkedList是双向链表，ArrayList支持下标查询，LinkedList不支持，ArrayList和LinkedList遍历时间复杂度都是O(n)，ArrayList尾部的增删，LinkedList头尾节点的增删时间复杂度都是O(1)，其他位置的增删的时间复杂度是O(n)。\nArrayList底层是数组，需要连续的内存，节省内存，LinkedList则需要存储数据和两个指针，更占用内存。\n\n\n【ArrayList和LinkedList都不是线程安全的，如何解决线程安全问题？】\n主要有两种解决方案，一个是在局部变量中使用，不会出现线程安全问题，第二个是用Collections的synchronizedList方法将ArrayList转换成线程安全的容器，用ConcurrentLinkedQueue替换LinkedList来使用。\n","categories":["java面试"],"tags":["Java集合"]}]