[{"title":"vue-element-admin之增删改查","url":"/2025/04/20/vue-element-admin%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","content":"介绍： 是一个后台前端解决方案，它基于 vue 和 element-ui实现。它使用了最新的前端技术栈，内置了 i18 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型\n\n\n\n\n下面就以用户管理为例来讲讲增删改查吧数据库结构：\n\n\n\n\n\n\n页面成品：\n\n\n\n\n概述： 总结常见的增删改查细节： \n（1） element-ui 数据呈现的形式\n（2） 相关函数的调用细节\n\n\n\n查询：比较常规，查询表单绑定提交的查询数据模型，点击按钮触发提交方法，方法调用@&#x2F;api中的方法调用后端接口，返回数据，表格绑定指定数据并通过数据的属性一一呈现。\n\n\n值得一提的是以下三种情况：\n\n\n(1) 后台返回部门树形结构数据并通过前端呈现，其中涉及到 递归 的使用：\n\n\n\n后端：\n   public static List&lt;Dept&gt; buildTree(List&lt;Dept&gt; deptList, int pid) &#123;           // 0；父节点 其他：子节点           List&lt;Dept&gt; deptTree = new ArrayList&lt;&gt;();           Optional.ofNullable(deptList).orElse(new ArrayList&lt;&gt;())                   .stream().filter(dept -&gt; dept!=null &amp;&amp; dept.getPid()==pid)                   .forEach(dept -&gt; &#123;                       Dept dept1 = new Dept();                       BeanUtils.copyProperties(dept, dept1);                       dept1.setChildren(buildTree(deptList, dept.getId()));                       deptTree.add(dept1);                   &#125;);           return deptTree;       &#125;      // 查询所有的dept表数据 List&lt;Dept&gt; deptList，再添加顶部数据：   Dept dept = new Dept();   dept.setDeptName(&quot;所有部门&quot;).setId(0).setPid(-1);   deptList.add(dept);   // 构造树形数据结构return DeptTreeUtils.buildTree(deptList, -1);\n\n\n\n前端：\n   &lt;el-tree :data=&quot;treeData&quot; :props=&quot;defaultProps&quot; node-key=&quot;id&quot; :default-expand-all=&quot;true&quot; empty-text=&quot;暂无数据&quot; @node-click=&quot;handleNodeClick&quot; :highlight-current=&quot;true&quot;&gt;&lt;/el-tree&gt;      &lt;!--   props: 呈现的属性   node-key 的作用：只是告诉组件用哪个字段作为节点的唯一标识（类似主键），用于组件内部管理节点状态（如展开、选中、查找等）。   handleNodeClick 的作用：点击节点时，它会传递完整的节点数据对象给你   其他： 默认展开， 校验， 点击事件， 选中高亮显示   --&gt;      handleNodeClick(data) &#123;    this.userModel.deptId = data.id;       this.search();&#125;,\n\n好的，如此便可呈现树形结构数据了，点击既可将dept_id赋值给userModel的deptId属性，实现查询功能。\n\n\n此时，便有一个问题了，点击顶级菜单”所有部门”为什么会发生查询所有用户？这就需要向内看看查询的逻辑了：\n逻辑很寻常，我设置的所有用户的dept_id都为空，读取mysql数据库的dept_id列时，ResultSet.getInt()会返回0，而顶级菜单的id即为0，所以查询全部用户。😂\n\n\n\n\n(2) 复选框\n\n\n\n相对来讲比较简单: 就是点击按钮向后端请求所有选项数据roleList，呈现的属性是roleName, 值（label）为id，默认选项为el-checkbox-group标签的绑定模型roleIds内的元素，点选复选框，可改变roleIds内的元素，以下为前端标签结构：\n\n\n&lt;el-dialog title=&quot;角色绑定&quot; :visible.sync=&quot;dialogRoleVisible&quot; width=&quot;30%&quot;&gt;    &lt;el-checkbox-group v-model=&quot;roleIds&quot;&gt;        &lt;el-checkbox v-for=&quot;item in roleList&quot; :key=&quot;item.id&quot; :label=&quot;item.id&quot;&gt;&#123;&#123;item.roleName&#125;&#125;&lt;/el-checkbox&gt;    &lt;/el-checkbox-group&gt;    &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;        &lt;el-button @click=&quot;clearBind&quot;&gt;取消&lt;/el-button&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;handleBindRole&quot;&gt;确定&lt;/el-button&gt;    &lt;/div&gt;&lt;/el-dialog&gt;\n\n\n\n处理逻辑： 点击角色绑定按钮，向后台发送2个请求 ：（1）所有的角色数据  （2）与用户联系的角色id\n点选复选框之后，发送请求携带userId和roleList，后台先删除userId相关联的roleId, 在批量插入用户角色关系。😁\n\n\n\n\n（3）分页查找的逻辑\n\n单表分页查询的情况下，可以直接使用baseMapper.selectByPage(page, 查询对象)\n\n\n多表联合查询的情况下:\n使用：baseMapper.searchByPage(page, autoInfo);AutoInfoMapper中定义searchByPage方法Page&lt;AutoInfo&gt; searchByPage(Page&lt;AutoInfo&gt; page, AutoInfo autoInfo);Mapper.xml中：AutoInfo.xml：&lt;select id=&quot;searchByPage&quot; resultType=&quot;com.coder.rental.entity.AutoInfo&quot;&gt;    select i.*, m.name, b.brand_name     from auto_info i, auto_maker m, auto_brand b\twhere i.maker_id = m.id and i.brand_id = b.id 后续为对象条件查询&lt;/select&gt;\n\n值得注意的是，这里传入的page对象好像在查询中用不到，应该在返回中使List&lt;.AutoInfo.&gt;自动转化成Page对象吧，挺邪乎的😒\n\n\n\n\n（4）根据身份证号确定出生日期,性别和年龄\n\n&lt;el-form-item label=&quot;身份证号&quot; prop=&quot;idNum&quot;&gt;    &lt;el-input v-model=&quot;saveCustomer.idNum&quot; @change=&quot;setCustomerInfo&quot;&gt;&lt;/el-input&gt;&lt;/el-form-item&gt;               &lt;el-form-item label=&quot;客户年龄&quot; prop=&quot;age&quot;&gt;    &lt;el-input v-model=&quot;saveCustomer.age&quot; :readonly=&quot;true&quot;&gt;&lt;/el-input&gt;&lt;/el-form-item&gt;&lt;el-form-item label=&quot;客户性别&quot; prop=&quot;gender&quot;&gt;    &lt;el-radio-group v-model=&quot;saveCustomer.gender&quot;&gt;        &lt;el-radio-button :label=&quot;1&quot; disabled&gt;男&lt;/el-radio-button&gt;        &lt;el-radio-button :label=&quot;0&quot; disabled&gt;女&lt;/el-radio-button&gt;    &lt;/el-radio-group&gt;&lt;/el-form-item&gt;&lt;el-form-item label=&quot;出生日期&quot; prop=&quot;birthday&quot;&gt;    &lt;el-date-picker v-model=&quot;saveCustomer.birthday&quot;                    type=&quot;date&quot; placeholder=&quot;选择日期&quot;                    value-format=&quot;yyyy-MM-dd&quot; :readonly=&quot;true&quot;&gt;    &lt;/el-date-picker&gt;&lt;/el-form-item&gt;&lt;script&gt;    setCustomerInfo(val) &#123;        //220202199911312661        //处理性别        const sex = val.charAt(val.length - 2)        this.saveCustomer.gender = sex % 2        //获取用户身份证上的出生日期        const birthday = val.substring(6, 14)        //当前系统时间        const now = new Date()        const birthDate = new Date(birthday.substring(0, 4), birthday.substring(4, 6) - 1, birthday.substring(6, 8))        let timeDiff = Math.abs(now.getTime() - birthDate.getTime())        if (timeDiff &gt; 0) &#123;            //计算年龄            this.saveCustomer.age = Math.floor(timeDiff / (1000 * 60 * 60 * 24 * 365))            //计算出生日期            this.saveCustomer.birthday = birthDate//birthday.substring(0,4)+&quot;-&quot;+birthday.substring(4,6)+&quot;-&quot;+birthday.substring(6,8)        &#125;        this.$forceUpdate()    &#125;&lt;/script&gt;\n\n\n\n\n\n(5) 日期选择&lt;el-form-item&gt;    &lt;el-date-picker v-                    model=&quot;violationModel.violationTimeVal&quot; type=&quot;datetimerange&quot;                    value-format=&quot;yyyy-MM-dd HH:mm:ss&quot; :picker-                    options=&quot;pickerOptions&quot; range-separator=&quot;至&quot;                    start-placeholder=&quot;开始日期&quot; end-placeholder=&quot;结束日期&quot;                    align=&quot;right&quot;&gt;    &lt;/el-date-picker&gt;&lt;/el-form-item&gt;&lt;el-form-item label=&quot;违章时间&quot; prop=&quot;vtime&quot;&gt;    &lt;el-date-picker v-model=&quot;saveViolation.vtime&quot;                    type=&quot;datetime&quot; placeholder=&quot;选择日期&quot;                    value-format=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;&lt;/el-form-item&gt;&lt;!--后端实体类数据：@ApiModelProperty(&quot;违章时间&quot;)@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)private LocalDateTime vtime;--&gt;\n\n\n\n\n\n(6) 下拉框车辆保养的新增选择车牌，车辆信息新增所属厂商，汽车出租\n\n\n\n\n(7) 侧边栏\n添加和修改：弹出添加修改对话框，注意延迟校验，表单绑定保存数据模型saveUser，此时有寻常编辑的情况，有点击弹出树形结构，进行点选的情况（上面查询时已经介绍过了）， 这里重点介绍上传头像的情况：\n\n对，我们用到的就是aliyun的oss服务，详细的上传和删除请参考阿里云上传和删除图片，我们这里只谈一谈增添头像的逻辑：\n点击上传图片，后端返回图片地址，前端利用地址显示图片即可\n所以这里只讨论前端：\n&lt;el-form-item label=&quot;用户头像&quot; prop=&quot;avatar&quot;&gt;    &lt;el-upload               class=&quot;avatar-uploader&quot;               :action=&quot;uploadPath&quot;               :show-file-list=&quot;false&quot;               :on-success=&quot;handleAvatarSuccess&quot;               :before-upload=&quot;beforeAvatarUpload&quot;               :data=&quot;uploadToken&quot;&gt;        &lt;img v-if=&quot;saveUser.avatar&quot; :src=&quot;saveUser.avatar&quot; class=&quot;avatar&quot; width=&quot;80&quot;&gt;        &lt;i v-else class=&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;/i&gt;    &lt;/el-upload&gt;&lt;/el-form-item&gt;&lt;script&gt;export default &#123;    data() &#123;        return &#123;            uploadPath: process.env.VUE_APP_BASE_API + &#x27;rental/oss/upload&#x27;,            uploadToken: &#123;token: getToken()&#125;,        &#125;    &#125;,        methods: &#123;        handleAvatarSuccess(res, file) &#123;            this.saveUser.avatar = res.data;            this.$forceUpdate();        &#125;,        beforeAvatarUpload(file) &#123;            // 上传头像之前的验证            const isJPG = file.type === &#x27;image/jpeg&#x27; || file.type === &#x27;image/png&#x27;;            const isLt2M = file.size/1024/1024 &lt; 2;            if (!isJPG) &#123;                this.$message.error(&#x27;上传头像只能是 JPG 或 PNG 格式！&#x27;);            &#125;            if (!isLt2M) &#123;                this.$message.error(&#x27;上传头像大小不能超过2MB!&#x27;);            &#125;            return isJPG &amp;&amp; isLt2M;        &#125;,    &#125;&#125;&lt;/script&gt;\n\nok，正如上所示，有上传地址，携带token令牌，上传之前进行验证，上传成功后图片地址赋值给saveUser.avatar\n\n\n这里有一个问题：\n以下两个语句的引用逻辑：\nimport &#123; getToken &#125; from &#x27;@/utils/auth&#x27;;// VUE_APP_BASE_API 定义在 @/env.development文件下（）, 可以直接通过process引用uploadPath: process.env.VUE_APP_BASE_API + &#x27;rental/oss/upload&#x27;, // getToken() 定义在@/utils/auth中uploadToken: &#123;token: getToken()&#125;,    // 好的，我们来看一下token的获取过程：就是封装的Cookies中获取// @/utils/auth.js: import Cookies from &#x27;js-cookie&#x27;const TokenKey = &#x27;Admin-Token&#x27;export function getToken() &#123;  return Cookies.get(TokenKey)&#125;\n\n\n\n\n删除\n\n这里的删除可以是指定行的元素删除，也可以是选中数行进行批量删除\n\n\n指定行的删除： 卡槽获取对象，将对象传入删除函数根据id进行删除\n批量删除： 利用 el-table-column type&#x3D;”selection” 构建基本复选框，点击时触发 el-table @selection-change事件\n下面来详细看看批量删除的元素勾选：\n&lt;script&gt;export default &#123;    data() &#123;        return &#123;            multipleSelection: [],  // 获取删除的批量id        &#125;    &#125;,        methods: &#123;         handleSelectionChange(val) &#123;            this.multipleSelection = [];            val.forEach(element =&gt; &#123;            this.multipleSelection.push(element.id);            &#125;);        &#125;,    &#125;&#125;&lt;/script&gt;\n\n每次点击的时候要清除multipleSelection\n\n\nok了，一些常见的增删改查操作已经总结完毕，如果后续出现新的情况，会进行补充的🎃\n","categories":["vue","vue-element-admin","java项目","汽车租赁管理系统"],"tags":["vue","vue-element-admin"]},{"title":"GitHub Page + Hexo 创建个人博客","url":"/2025/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"介绍： 编写md格式文件，使用 Hexo 渲染成静态网页文件，用git上传至github仓库（仓库名即用户名），可由 仓库名.github.io 地址访问。\n\n\n一. 初次使用：\n环境准备：\ngit\nnode（版本14.0.0+）\n\n\nHexo安装：\nnpm install -g hexo-cli\n\n\n\n初始化框架, 创建工作文件夹test:\nnpm init test;npm install; // 安装框架所需\n\n\n\n生成静态网页\nhexo g\n\n\n\n\n启动服务\nhexo s\n\n\n\n​\t访问 127.0.0.1:4000 查看页面效果。\n\n\n\n\n二. Next主题:\n下载next主题：\ncd testgit clone https://github.com/iissnan/hexo-theme-next themes/next\n\n\n\n_config.yml 文件找到 theme, 更改：\ntheme: next\n\n\n\n选择主题形式： 在&#x2F;theme&#x2F;next&#x2F;_config.yml找到 scheme\n# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini  # 推荐\n\n\n\n设置语言：在_config.yml中找到 language， 设置：\nlanguage: zh-Hans # 默认en\n\n\n\n设置菜单： 在&#x2F;theme&#x2F;next&#x2F;_config.yml找到 menu\nmenu:  home: /              # 首页  archives: /archives  # 归档  #about: /about  #categories: /categories  #tags: /tags  #commonweal: /404.html\n\n\n\n\n\n\n若你的站点运行在子目录中，请将链接前缀的 &#x2F; 去掉\n\n\n\n\n\n\n三. 修改个人信息\n编辑_config.yml， 设置author，title,  subtitle, description等:\n# Sitetitle: yourTitle   #标题subtitle: &#x27;&#x27;       #副标题description: &#x27;&#x27;keywords:author: you        #作者language: zh-Hans  #语言timezone: &#x27;Asia/Shanghai&#x27; #时区\n\n\n\n设置头像： 在source文件夹下创建 image文件夹，放置图片\navatar: /images/博客头像.png  # /images/图片.png   图片的格式 \n\n\n\n\n\n四. 编写文章编写md格式文章，放在 source&#x2F;_posts 文件夹下\nhexo new &quot;post title&quot; # 创建文章，默认md格式host g  # 全部原文章渲染到public静态目录\n\n\n\n\n\n五. 上传至github\n安装一键部署插件：\nnpm install hexo-deployer-git --save\n\n\n\n_config.yml中添加部署配置：\ndeploy:  type: git  repo: git@github.com:&lt;username&gt;/&lt;project&gt;  #example,https://github.com/hexojs/hexojs.github.io  branch: master  # 上传github仓库分支，可更改\n\n\n\n上传：\nhexo d\n\n\n\n访问地址：yourUserName.github.io  (注意你上传的仓库名和你的github的用户名必须相同！)\n\n\n\n\n恭喜你已经创建了属于你的博客。\n","categories":["hexo"],"tags":["创建博客","hexo"]},{"title":"阿里云OSS","url":"/2025/04/20/%E9%98%BF%E9%87%8C%E4%BA%91OSS/","content":"介绍： 有时，我们将图片等静态资源存储在服务器上，但当图片多时，网站加载图片等静态资源的时间会变长，服务体检就会打折扣，这时我们就可以借助阿里云等云服务的对象存储服务直接上传图片，在网站html页面引用图片地址即可。\n\n\n\n\nspringboot如何介入aliyun OSS服务呢?  那么现在开始吧\n\n\n\n首先是在 springboot 配置文件 application.yml 中加入以下:\naliyun:  oss:    endpoint:    access-key-id:    access-key-secret:    bucket-name:\n\n需要注册阿里云的OSS服务才可以有bucket-name和endpoint, 身份认证的两个属性：access-key-id 和 access-key-secret\n\n\n\n\n再把它封装成一个对象OSSConfig, 方便操作👍\nimport lombok.Data;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component@Datapublic class OSSConfig &#123;    @Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)    private String endpoint;    @Value(&quot;$&#123;aliyun.oss.access-key-id&#125;&quot;)    private String accessKeyId;    @Value(&quot;$&#123;aliyun.oss.access-key-secret&#125;&quot;)    private String accessKeySecret;    @Value(&quot;$&#123;aliyun.oss.bucket-name&#125;&quot;)    private String bucketName;&#125;\n\n\n\n\n\n再就是创建一个接口及其实现类，完成图片的上传和删除逻辑：\n// 先创建IOssService，定义上传和删除方法import cn.hutool.core.util.StrUtil;import com.aliyun.oss.OSS;import com.aliyun.oss.OSSClientBuilder;import com.coder.rental.config.OSSConfig;import com.coder.rental.service.IOssService;import com.coder.rental.utils.FileUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;@Servicepublic class OssServiceImpl implements IOssService &#123;    @Autowired    private OSSConfig ossConfig;    public String upload(MultipartFile file) &#123;        String originalFilename = file.getOriginalFilename();        String fileName = FileUtils.getFileName(originalFilename);        OSS ossClient = new OSSClientBuilder().build(                ossConfig.getEndpoint(),                ossConfig.getAccessKeyId(),                ossConfig.getAccessKeySecret()        );        try &#123;            // 完成上传处理            ossClient.putObject(ossConfig.getBucketName(), fileName, file.getInputStream());            return &quot;https://&quot; + ossConfig.getBucketName() + &quot;.&quot; +  ossConfig.getEndpoint() + &quot;/&quot; + fileName;        &#125; catch (Exception e) &#123;            throw new RuntimeException(&quot;上传文件失败&quot;);        &#125; finally &#123;            if (ossClient != null) &#123;                ossClient.shutdown();            &#125;        &#125;    &#125;    @Override    public boolean delete(String url) &#123;        OSS ossClient = new OSSClientBuilder().build(                ossConfig.getEndpoint(),                ossConfig.getAccessKeyId(),                ossConfig.getAccessKeySecret()        );        String host = &quot;https://&quot; + ossConfig.getBucketName() + &quot;.&quot; + ossConfig.getEndpoint() + &quot;/&quot;;        String objectName = StrUtil.removePrefix(url, host);        try &#123;            ossClient.deleteObject(ossConfig.getBucketName(), objectName);            return true;        &#125; catch (Exception e) &#123;            throw new RuntimeException(&quot;删除失败&quot;);        &#125; finally &#123;            if (ossClient != null) &#123;                ossClient.shutdown();            &#125;        &#125;    &#125;&#125;\n\n\n\n\n\n最后就是 controller 层的调用了\n\n\n\n\n就是这么简单\n\n\n","categories":["云服务","阿里云OSS"],"tags":["阿里云OSS"]},{"title":"vue-element-admin初始搭建","url":"/2025/04/23/vue-element-admin%E5%88%9D%E5%A7%8B%E4%BD%BF%E7%94%A8/","content":"介绍： 初始搭建是在后端的访问权限模块完成之后进行的，主要内容为登录退出，菜单路由导航这两部分，构建一个大体框架，之后内容的编写就只需注重内容本身即可。\n\n\n一. vue-element-admin安装\n\n\n\n二.后端\n用户登录获取该用户信息(id, 用户名, 头像, 角色名称数组)\n@GetMapping(&quot;/getInfo&quot;)public Result getUserInfo() &#123;    // 从securityContextHolder上下文中获取认证信息    Authentication authentication =        SecurityContextHolder.getContext().getAuthentication();    if (authentication == null) &#123;        return Result.fail().setMessage(&quot;认证信息为空&quot;);    &#125;    User user = (User) authentication.getPrincipal();    // 查询用户角色名称    /*List&lt;String&gt; list = userService.selectRoleName(user.getId());       Object[] array = list.toArray(); */// 将角色名称列表转换为数组    List&lt;Permission&gt; permissionList = user.getPermissionList();    Object[] array = permissionList.stream().filter(Objects::nonNull)        .map(Permission::getPermissionCode)        .toArray();    // 创建并填充用户信息视图对象    UserInfoVo userInfoVo = new UserInfoVo(user.getId(),                                           user.getUsername(),                                           user.getAvatar(), user.getNickname(), array);    return Result.success(userInfoVo).setMessage(&quot;获取用户信息成功&quot;);&#125;\n\n注意角色数组要用 Permission 中的 permissionCode\n\n\n参照router-&gt;index.js中的路由选项，编写routerVO\n&#123;    path: &#x27;/error&#x27;,    component: Layout,    redirect: &#x27;noRedirect&#x27;,    name: &#x27;ErrorPages&#x27;,    meta: &#123;      title: &#x27;Error Pages&#x27;,      icon: &#x27;404&#x27;,      roles: [&#x27;admin&#x27;, &#x27;editor&#x27;]    &#125;,    children: [      &#123;        path: &#x27;401&#x27;,        component: () =&gt; import(&#x27;@/views/error-page/401&#x27;),        name: &#x27;Page401&#x27;,        meta: &#123; title: &#x27;401&#x27;, noCache: true &#125;      &#125;,      &#123;        path: &#x27;404&#x27;,        component: () =&gt; import(&#x27;@/views/error-page/404&#x27;),        name: &#x27;Page404&#x27;,        meta: &#123; title: &#x27;404&#x27;, noCache: true &#125;      &#125;    ]&#125;\n\n\n\n@Data@JsonInclude(JsonInclude.Include.NON_EMPTY) // 注意加上该注解，不序列化空childrenpublic class RouteVO &#123;    private String path;    private String component;    private String name;    private Boolean alwaysShow;    private Meta meta;    private List&lt;RouteVO&gt; children;    @Data    @NoArgsConstructor    @AllArgsConstructor    public class Meta &#123;        private String title;        private String icon;        private String[] roles;    &#125;&#125;\n\n\n\n根据权限列表，经过路由菜单工具类获取路由信息\n@GetMapping(&quot;/menuList&quot;)public Result getMenuList() &#123;    //获取当前用户信息    Authentication authentication =        SecurityContextHolder.getContext().getAuthentication();    if (authentication == null) &#123;        return Result.fail().setMessage(&quot;认证信息为空&quot;);    &#125;    User user = (User) authentication.getPrincipal();    //获取用户的权限列表    List&lt;Permission&gt; permissionList = user.getPermissionList();    //获取用户的菜单    //将permission_type为2的按钮移除，不需要生成对应的菜单    permissionList.removeIf(permission -&gt;                            Objects.equals(permission.getPermissionType(), 2));    List&lt;RouteVO&gt; routeVOList =        RouteTreeUtils.buildRouteTree(permissionList, 0);    return Result.success(routeVOList).setMessage(&quot;获取菜单列表成功&quot;);&#125;\n\n\n\n退出登录接口\n@PostMapping(&quot;/logout&quot;)public Result logout(HttpServletRequest request, HttpServletResponse                     response)&#123;    String token=request.getHeader(&quot;token&quot;);    if (StrUtil.isEmpty(token))&#123;        token=request.getParameter(&quot;token&quot;);    &#125;    Authentication authentication =        SecurityContextHolder.getContext().getAuthentication();    if (authentication!=null)&#123;        //用户一旦登出系统，则清除redis中的token        redisUtils.del(&quot;token:&quot;+token);        SecurityContextLogoutHandler handler = new            SecurityContextLogoutHandler();        handler.logout(request,response,authentication);        return Result.success().setMessage(&quot;登出成功&quot;);    &#125;    return Result.fail().setMessage(&quot;登出失败&quot;);&#125;\n\n\n\n这个时候后端就完成了，总结以下后端完成内容吧🎃：\n（1）获取用户信息  （2）获取路由信息   （3）退出登录\n\n\n\n\n\n\n三.前端之登录退出\n\n\n好的，我们现在开始前端部分，首先是前端登录：先稍微修改一下前端页面😁，然后就有一个问题了，怎么让前端发送登录请求到后端呢？我们来解决：\n\n\n\n（1）先修改以下开发环境**.env.development和生产环境.env.production**的文件：\nVUE_APP_BASE_API = &#x27;http://localhost:8888/&#x27;\n\n\n\n（2） 然后修改发送请求的文件request.js:\n\n\n​\t安装qs依赖，实现参数序列化处理：\nnpm install qs\n\n\n\n​\t修改service，用 process.env.VUE_APP_BASE_API 来表示要发送的服务器及其端口\n// create an axios instanceconst service = axios.create(&#123;    baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url    // withCredentials: true, // send cookies when cross-domain requests    timeout: 5000 // request timeout&#125;)// 接下来就是request拦截, 在Header中放置token// response拦截，判断响应code来做处理// 定义requestHttp,用于发送请求：get, post, put, delete, upload, login// 下面以post为例：post(url,params) &#123;    return service.post(        url, params, &#123;            transformRequest: [(params) =&gt; &#123;                return JSON.stringify(params)            &#125;],            headers: &#123;                &#x27;Content-Type&#x27;: &#x27;application/json&#x27;            &#125;        &#125;,    )&#125;// service的post方法发送的url参数和自身定义时的baseUrl相结合。\n\n\n\n好的，我们来总结一下发送请求的问题吧，发送请求的方式是Axios，定义service时设置baseURL为服务器及其端口，后续调用service方法请求时，传入请求路径（在baseURL的基础上）和参数即可。\n\n\n（3）我们搞清楚请求路径之后就可以在api&#x2F;user.js中定义请求方法用于获取用户信息和路由信息了\n\n\n（4） 登录的最后部分，还有一些小细节需要修改╰(°▽°)╯： 返回的token需要存储呀：\nimport &#123; getToken, setToken, removeToken &#125; from &#x27;@/utils/auth&#x27;const state = &#123;  token: getToken(),  name: &#x27;&#x27;,  avatar: &#x27;&#x27;,  introduction: &#x27;&#x27;,  roles: [],  createrId: &#x27;&#x27;&#125;const mutations = &#123;  SET_TOKEN: (state, token) =&gt; &#123;    state.token = token  &#125;,&#125;// user loginlogin(&#123; commit &#125;, userInfo) &#123;    const &#123; username, password &#125; = userInfo    return new Promise((resolve, reject) =&gt; &#123;        login(&#123; username: username.trim(), password: password &#125;).then(response =&gt; &#123;            const &#123; token &#125; = response            commit(&#x27;SET_TOKEN&#x27;, token)            setToken(token)            resolve()        &#125;).catch(error =&gt; &#123;            reject(error)        &#125;)    &#125;)&#125;,\n\n登录成功后，state就可以存储user信息了\n\n\n\n\n\n那么接下来就是退出登录了:\n\n\n（1）在 api&#x2F;user.js 中定义退出方法：\nexport async function logout(param)&#123; return await requestHttp.post(&#x27;/rental/auth/logout&#x27;,param)&#125;\n\n\n\n（2）在 utils&#x2F;auth.js 中定义清除 sessionStorage 方法：\nexport function removeSessionStoreage()&#123;    return sessionStorage.clear()&#125;\n\n\n\n（3） 修改 layout&#x2F;components&#x2F;Navbar.vue 文件：\nimport &#123;logout&#125; from &#x27;@/api/user&#x27;import &#123;getToken, removeToken, removeSessionStorage&#125; from &#x27;@/utils/auth&#x27;logout() &#123;      //修改logout方法     //await this.$store.dispatch(&#x27;user/logout&#x27;)     //this.$router.push(`/login?redirect=$&#123;this.$route.fullPath&#125;`)     this.$confirm(&#x27;确定退出系统吗?&#x27;, &#x27;提示&#x27;, &#123;       confirmButtonText: &#x27;确定&#x27;,       cancelButtonText: &#x27;取消&#x27;,       type: &#x27;warning&#x27;    &#125;).then(async() =&gt; &#123;       let token = &#123; token: getToken &#125;    // 获取token       let res = await logout(token)      // 调用退出登录方法       if (res.success)&#123;         removeToken()\t// 去除token         removeSessionStoreage()    // 清除SessionStoreage             this.$router.push(`/login?redirect=$&#123;this.$route.fullPath&#125;`)      &#125;    &#125;).catch(() =&gt; &#123;       this.$message(&#123;         type: &#x27;info&#x27;,         message: &#x27;已取消退出&#x27;      &#125;);   &#125;);&#125;\n\n\n\n\n\n前端之动态路由菜单登录时获取了用户信息和路由信息，其中用户信息存储在 store&#x2F;modules&#x2F;user.js 的state中，而获取的路由信息得转化为动态路由菜单，好的，现在我们来开始这一部分：\n\n\n\n在 api&#x2F;user.js 中，写获取菜单的方法:\nexport async function getMenuList()&#123;    return await requestHttp.get(&#x27;/rental/auth/menuList&#x27;)&#125;\n\n\n\n修改 store&#x2F;permission.js 文件，实现动态路由菜单\nconst actions = &#123;    generateRoutes(&#123; commit &#125;, roles) &#123;        return new Promise((resolve, reject) =&gt; &#123;            getMenuList().then(response =&gt; &#123;                if (response.code === 200) &#123;                    const accessedRoutes = filterAsyncRoutes(response.data, roles)                    commit(&#x27;SET_ROUTES&#x27;, accessedRoutes)                    resolve(accessedRoutes)  // 进行索引导航                &#125; else &#123;                    reject(response.msg)                &#125;            &#125;).catch(                error =&gt; &#123;                    reject(error)                &#125;)        &#125;)    &#125;&#125;// 此时getMenuList()的response.data要经过filterAsyncRoutes递归处理export function filterAsyncRoutes(routes, roles) &#123;    const res = []    routes.forEach(route =&gt; &#123;        const tmp = &#123; ...route &#125;        if (hasPermission(roles, tmp)) &#123;            let component = tmp.component  // 组件对应permission中的route_url            if (route.component) &#123;                if (component === &#x27;Layout&#x27;) &#123;                    tmp.component = Layout  // 默认布局已经存在该组件                &#125; else &#123;                    tmp.component = (resolve) =&gt; require([`@/views$&#123;component&#125;`],                                                         resolve)                &#125;            &#125;            if (tmp.children) &#123;                tmp.children = filterAsyncRoutes(tmp.children, roles)            &#125;            res.push(tmp)        &#125;    &#125;)    return res&#125;const mutations = &#123;    SET_ROUTES: (state, routes) =&gt; &#123;        state.addRoutes = routes        state.routes = constantRoutes.concat(routes)    &#125;&#125;// 经过处理后的routes保存在route的routes属性中const state = &#123; routes: [], addRoutes: []&#125;\n\n\n\n好，我们来总结一下动态索引菜单是如何进行的：向后端请求得到数据后，用filterAsyncRoutes递归处理索引路径 component, 就可以进行存储和转换了。\n\n\n\n\n最后，还有一些细节需要修改：\n（1）修改router-&gt;index.js文件，注释掉document和guide菜单，并将dashboard改成”首页”字样\n（2）修改utils-&gt;validate.js文件，对用户名的校验\nexport function validUsername(str) &#123;    //const valid_map = [&#x27;admin&#x27;, &#x27;editor&#x27;]    return str.length&gt;0;&#125;\n\n（3）修改layout-&gt;components-&gt;Navbar.vue文件\nlogout() &#123;      //修改logout方法     //await this.$store.dispatch(&#x27;user/logout&#x27;)     //this.$router.push(`/login?redirect=$&#123;this.$route.fullPath&#125;`)     this.$confirm(&#x27;确定退出系统吗?&#x27;, &#x27;提示&#x27;, &#123;       confirmButtonText: &#x27;确定&#x27;,       cancelButtonText: &#x27;取消&#x27;,       type: &#x27;warning&#x27;    &#125;).then(async() =&gt; &#123;       let token = &#123; token: getToken &#125;    // 获取token       let res = await logout(token)      // 调用退出登录方法       if (res.success)&#123;         removeToken()\t// 去除token         removeSessionStoreage()    // 清除SessionStoreage             // this.$router.push(`/login?redirect=$&#123;this.$route.fullPath&#125;`)         window.location.href = &#x27;/&#x27;      &#125;    &#125;).catch(() =&gt; &#123;       this.$message(&#123;         type: &#x27;info&#x27;,         message: &#x27;已取消退出&#x27;      &#125;);   &#125;);&#125;\n\n\n\n\n\n\n\n结语目前已经完成了项目的前端大体框架，后续在进行访问权限模块和项目各部分模块之间的关系总结。\n(&#x2F;ω＼)\n","categories":["vue","vue-element-admin","java项目","汽车租赁管理系统"],"tags":["vue"]},{"title":"vue-element-admin之财务管理","url":"/2025/04/24/%E7%BB%9F%E8%AE%A1%E5%9B%BE_excel%E5%AF%BC%E5%87%BA_%E5%8F%91%E9%82%AE%E4%BB%B6/","content":"介绍：在这一部分，我们可以学习三个小知识： echarts 统计图， excel 导出 和 发送邮件。\n\n\n\n一.  echarts统计图\n\necharts中文官网, 这里我们只看重叠折线统计图，简要思路就是 x轴数据为小时或日期数组，而series的数组为所展现的数据的大小，这两部分的数组索引一一对应。\n\n\n示例效果：\n\n\n\n\n&lt;el-card&gt;    &lt;div&gt;        &lt;div ref=&quot;Mychart&quot; :style=&quot;&#123; width: &#x27;80%&#x27;, height: &#x27;400px&#x27; &#125;&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/el-card&gt;&lt;script&gt;export default &#123;    data() &#123;        return &#123;            Mychart: null,            xArray: [],            y1Array: [],        &#125;    &#125;,        mouted() &#123;      this.initRentalChart();    &#125;,        methods: &#123;        initRentalChart() &#123;            this.Mychart = echarts.init(this.$refs.Mychart);            this.Mychart.setOption(&#123;                title: &#123;                    text: &#x27;日报出租数据统计&#x27;,                    subtext: new Date().toLocaleDateString(),                &#125;,                tooltip: &#123; // 一些例如点选的效果                    trigger: &#x27;axis&#x27;,                    axisPointer: &#123;                        type: &#x27;shadow&#x27;                    &#125;                &#125;,                legend: &#123;                    data: [&#x27;出租数量&#x27;] // series内容数组                &#125;,                grid: &#123;                    left: &#x27;3%&#x27;,                    right: &#x27;4%&#x27;,                    bottom: &#x27;3%&#x27;,                    containLabel: true                &#125;,                toolbox: &#123;                    show: true,                    orient: &#x27;vertical&#x27;,                    left: &#x27;right&#x27;,                    top: &#x27;center&#x27;,                    feature: &#123; // 侧边栏：数据展示，图的切换，保存图片                        mark: &#123;show: true&#125;,                        dataView: &#123;readOnly: false, show: true&#125;,                        magicType: &#123;                            type: [&#x27;line&#x27;, &#x27;bar&#x27;],                            show: true                        &#125;,                        saveAsImage: &#123;show: true&#125;                    &#125;                &#125;,                xAxis: &#123;                    type: &#x27;category&#x27;,                    boundaryGap: false,                    axisTick: &#123;show: false&#125;,                    data: this.xArray                &#125;,                yAxis: &#123;                    type: &#x27;value&#x27;                &#125;,                series: [                    &#123;                    name: &#x27;出租数量&#x27;,                    // type: &#x27;bar&#x27;,                    type: &#x27;line&#x27;,                    // stack: &#x27;Total&#x27;,                    barGap: 0,                    data: this.y1Array                    &#125;,                ]            &#125;);        &#125;,    &#125;&#125;&lt;/script&gt;\n\n\n\n\n\n\n\n二. excel导出\n\n将对象数组转化为excel表，属性作为表头，可以起别名哦🎃。需要 hutool 依赖包来完成：\n\n\n导出效果：\n\n\n\n\nimport cn.hutool.poi.excel.ExcelUtil;import cn.hutool.poi.excel.ExcelWriter;@GetMapping(&quot;exportExcel&quot;)public void export(HttpServletResponse response) throws IOException &#123;    List&lt;AutoBrand&gt; list=autoBrandService.list();    // 列表转化为excel文件    ExcelWriter writer= ExcelUtil.getWriter(true);    writer.addHeaderAlias(&quot;brandName&quot;,&quot;品牌名称&quot;);    writer.addHeaderAlias(&quot;deleted&quot;,&quot;是否删除&quot;);    writer.write(list,true);    // 设置response格式和传输的文件名    response.setContentType(&quot;application/vnd.openxmlformats-                            officedocument.spreadsheetml.sheet;charset:utf-8&quot;);    String fileName= URLEncoder.encode(&quot;汽车品牌&quot;,StandardCharsets.UTF_8);    response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;                       filename=&quot;+fileName+&quot;.xlsx&quot;);                                      \t  writer.flush(response.getOutputStream(),true);    writer.close();&#125;\n\n\n\n\n\n\n\n三. 发邮件\n\n\n进行application.yml配置:\nspring:  mail:    host: smtp.163.com # smtp为简单邮件协议    port: 25    username: a838211536@163.com # 邮箱名    password: QNg9GeYBpeybQRMT # 授权密码    properties:      mail.smtp.auth: true # 启用认证      mail.smtp.starttls.enable: true  # 启用TLS      mail.smtp.starttls.required: true\n\n\n\n定义IMailService接口及其实习类MailServiceImpl, 需注意：如果javaMailSender无法自动注入的话，还需要自己写一个产生 javaMailSender bean 的配置类。\n\n\n@Servicepublic class MailServiceImpl implements IMailService &#123;    @Autowired    private JavaMailSender javaMailSender;    /**     * 发送邮件     *     * @param mail 邮件数据对象，包含以下关键字段：     *             - from:    发件人地址     *             - to:      收件人地址（支持多个）     *             - subject: 邮件主题     *             - content: 邮件正文内容     * 实现说明：     * 1. 使用SimpleMailMessage构建基础邮件信息     * 2. 设置发件人、收件人、主题、正文等核心字段     * 3. 将发件人同时添加到抄送列表（需确认是否符合业务需求）     * 4. 通过JavaMailSender执行邮件发送     *     * @throws MailException 当邮件发送失败时抛出相关异常     */    @Override    public void sendMail(MailVO mail) throws MailException &#123;        // 构建基础邮件消息对象        SimpleMailMessage message = new SimpleMailMessage();        // 设置邮件基本信息        message.setFrom(mail.getFrom());        message.setTo(mail.getTo());        message.setSubject(mail.getSubject());        message.setText(mail.getContent());        // 设置发件人同时作为抄送（根据业务需求可能需要调整）        message.setCc(mail.getFrom());        // 执行邮件发送操作        javaMailSender.send(message);    &#125;\n\n\n\n好的，到这里就可以进行邮件发送操作了，但是如何进行定时发送邮件呢？\n\n\n定时发送邮件, 这里就以财务管理的日报收入部分为例吧：\n@Componentpublic class SendMailUtil &#123;    @Autowired    private IFinanceService financeService;    @Autowired    private IMailService mailService;    @Value(&quot;$&#123;spring.mail.username&#125;&quot;)    private String from;    @Scheduled(cron = &quot;*/10 * * * * ?&quot;)    public void sendMail() &#123;        StringBuffer sbf = new StringBuffer();        sbf.append(&quot;今日收入：&quot;)                .append(&quot;，租金收入：&quot;)                .append(financeService.sumRentPay().getCountActualPayable())                .append(&quot;，押金收入：&quot;)                .append(financeService.sumDeposit());        MailVO mailVO = new MailVO();        // 设置四部分：from, to, subject, content        mailVO.setFrom(from);        mailVO.setTo(&quot;a838211536@163.com&quot;);        String date = LocalDate.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));        mailVO.setSubject(date + &quot;今日收入&quot;);        mailVO.setContent(sbf.toString());        mailService.sendMail(mailVO);    &#125;&#125;\n\n\n\n好的，这样看来，邮件发送就简单了：（1）javaMailSender的配置     （2）填写发送信息对象\n\n\n","categories":["vue","vue-element-admin","java项目","汽车租赁管理系统"],"tags":["echarts统计图","excel导出","发邮件"]},{"title":"Spring Security","url":"/2025/04/24/spring-security/","content":"介绍： 是一套后端访问和权限校验的框架，由一系列的过滤链组成，我们主要操作的是三部分：\n\n认证核心（UsernamePasswordAuthenticationFilter） \n\n处理认证和授权异常（ExceptionTranslationFilter）\n\n授权核心（FilterSecurity）\n\n\n我们主要从认证和授权这两个方面来总结。\n\n\n\n\n\n\n一. 认证\n\n认证就是认证核心 UsernamePasswordAuthenticationFilter 过滤器来进行的，我们来看一下流程图：\n\n\n\n\n\n\n\n用户初次登录\n\n具体流程： \n（1）接受用户发送请求携带的username和password，封装为Authentication对象，调用AuthenticaionManager（含有UserDetailsService接口实现类和PasswordEncoder密码校验）\n\n\n（2） UserDetailsService接口实现类根据username查询用户信息，及其权限信息，封装到UserDetails对象实现类里。经过PasswordEncoder的接口实现类BCryptPasswordEncoder的校验，通过校验则将UserDetails接口实现类对象封装到Authentication对象里, 不通过则到登录失败处理器返回登录失败信息。\n\n\n（3）最后将对象返回并且存入SecurityContextHolder.getContext()里。\n\n\n（4）存入并返回token: 通过UsernamePasswordAuthenticationFilter后，到达登录成功处理器LoginSucessHandler，首先根据 Authentication对象 获取 User 对象（封装用户信息和权限信息），再提取 username 和 userId 生成token, outputStream流返回token并将token，及有效时间长度存储到redis中。\n\n\n\n\n那便有一个问题了，这个登录成功处理器不在这三大过滤器之内呀，如何配置呢？哈哈，要经过SecurityConfig配置的，事实上，SecurityConfig是配置整个安全过滤器链的。\n@Configuration@EnableWebSecurity@EnableMethodSecuritypublic class SecurityConfig &#123;    @Autowired    private LoginSuccessHandler loginSuccessHandler;    @Autowired    private LoginFailHandler loginFailHandler;    @Autowired    private CustomerAccessDeniedHandler customerAccessDeniedHandler;    @Autowired    private CustomerAnonymousEntryPoint customerAnonymousEntryPoint;    @Autowired    private CustomerUserDetailsService customerUserDetailsService;    @Autowired    private  VerifyTokenFilter verifyTokenFilter;    /**     * 配置安全过滤器链     * @param http     * @return     * @throws Exception     */    @Bean    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;        // 登录前过滤配置        http.addFilterBefore(verifyTokenFilter, UsernamePasswordAuthenticationFilter.class);        //        http.formLogin()                .loginProcessingUrl(&quot;/rental/user/login&quot;) // 设置登录处理URL                .successHandler(loginSuccessHandler) // 设置登录成功处理器                .failureHandler(loginFailHandler) // 设置登录失败处理器                .and()                .sessionManagement()                .sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 设置会话创建策略为无状态                .and()                .authorizeHttpRequests() // 授权请求配置                .requestMatchers(&quot;/rental/user/login&quot;) // 匹配登录请求                .permitAll() // 允许所有请求访问                .anyRequest().authenticated() // 任何其他请求需要认证                .and()                .exceptionHandling() // 异常处理配置                .authenticationEntryPoint(customerAnonymousEntryPoint) // 设置未认证入口点                .accessDeniedHandler(customerAccessDeniedHandler) // 设置访问拒绝处理器                .and()                .cors() // 跨域配置                .and()                .csrf().disable() // 关闭CSRF保护  跨站请求伪造 是一种网络攻击                .userDetailsService(customerUserDetailsService); // 设置用户详情服务        return http.build(); // 构建并返回安全过滤链    &#125;&#125;\n\n\n\n\n\n我们可以看到配置的内容为：\n登录前：UsernamePasswordAuthenticationFilter\n登录失败，登录成功\n请求访问策略\n异常处理\n跨域配置\nuserDetailsService接口实现类\n\n\n\n\n\n用户携带token登录具体流程：用户携带token访问非login的url需要经过verifyTokenFilter验证，token为空，不在redis内，不可解析则抛出认证异常被登录失败处理器捕捉，否则解析username，调用UserDetailsService接口实现类进行查询用户信息和权限信息，封装到Authentication对象并存储到SecurityContextHolder.getContext()里。\n\n\n\n\n\n\n二. 授权\n\n\n前面我们调用UserDetailService实习类loadByUserName方法查询权限信息并且存储到UserDetail的实现类中，我们来看一下权限信息的创建过程：\n\n// 查询权限信息List&lt;Permission&gt; permissionList = permissionService.selectPermissionListByUserId(user.getId());user.setPermissionList(permissionList);// 通过stream流处理，将权限对象转化为权限字符串列表List&lt;String&gt; list = permissionList.stream().filter(Objects::nonNull)    .map(Permission::getPermissionCode)    .filter(Objects::nonNull)    .toList();String[] array = list.toArray(new String[list.size()]);List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.createAuthorityList(array);user.setAuthorities(authorityList);\n\n\n\n可以看到权限信息是根据permissionCode字段进行创建的。\n\n\n\n现在已知权限信息的具体格式，接下来看看具体的授权操作，以新增角色为例：\n@PostMapping@PreAuthorize(&quot;hasAuthority(&#x27;sys:role:add&#x27;)&quot;)public Result add(@RequestBody Role role) &#123;    role.setDeleted(false);    return roleService.save(role) ?  Result.success() : Result.fail();&#125;\n\n需要 PreAuthorize 注解 和 hasAuthority 方法就好了，方法参数即为上面提交的permissionCode😁\n\n\n现在授权大体已经讲完了，另外还可以自己定义hasAuthority方法呦🎃，我们来看看过程吧：\n@Component(&quot;ex&quot;)public class MyExpressionRoot &#123;    public boolean hasAuthority(String authority)&#123;        //获取身份令牌        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();        //获取权限        Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();        //循环判断        for (GrantedAuthority grantedAuthority : authorities) &#123;            String role = grantedAuthority.getAuthority(); // 获取string            if (role.equals(authority)) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;// 使用：@PreAuthorize(&quot;@ex.hasAuthority(&#x27;&#x27;)&quot;)\n\n结语好了，现在spring security已经总结完了，慢慢学习，思考和总结，熟练了就简单了😁\n","categories":["java项目","汽车租赁管理系统","java框架","SpringSecurity"],"tags":["SpringSecurity"]},{"title":"核心业务逻辑","url":"/2025/04/25/%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/","content":"介绍：总结一下汽车租赁管理系统的核心业务逻辑，有四大板块：\n（1）权限管理\n（2）数据初始\n（3）日常业务\n（4）财务管理\n这样是按照开发顺序来排的：我们的项目首先登录进去，根据登录用户的权限信息显示左侧菜单栏，车辆信息要进行设置，然后可以操作日常业务板块了，最后可以进行财务管理。\n\n\n\n\n一. 权限管理\n\n这一模块是我们整个项目的基础，用户—角色—权限资源 这三大部分相关联，当然还有部门—用户，这里主要介绍重点： 权限资源 permission 表，表中包含了四大板块所有的权限及其子权限。\n\n\n四大板块的权限分级：顶级目录(0), 菜单(1), 操作(2) \n\n\n那么就有一个问题了，我们登录用户的权限和这四大板块的权限有啥关系呀？其实可以从访问和操作这两部分出发：\n（1）访问： 顶级目录和菜单部分\n\n\n（2）操作：增删改查\n\n\n简单点说，就是，你用户的权限包含顶级目录和菜单，就可以在菜单侧边栏显示，再包含相关操作权限，就可以对相关页面进行相关操作。如果用户权限包括权限管理及其所有子权限，就可以在该板块编辑自己或其他用户的权限资源分配。\n\n\n了解了具体原理后，我们来看看这四个部分的功能\n\n部门管理：增删改查\n\n用户管理：增（选择部门，先删关联再添关联），删（删除与角色的关联），改，查，绑定角色\n\n角色管理：增，删（删除与用户关联，删除与权限关联），改，查，设置权限\n\n菜单管理：增删改查\n\n\n\n\n二. 数据初始\n\n这一部分就是设置车辆信息的，效果图如下：\n\n\n我们直接来看操作：\n\n车辆厂商：增删改查\n\n车辆品牌：增（选择车辆厂商），删，改，查（显示厂商名称）\n\n出租类型：增删改查\n\n车辆信息：增（所属厂商，所属品牌），删，改，查\n\n\n\n\n三. 日常业务\n\n这一部分就是重中之重了，效果图如下：\n\n\n（1）客户管理：增删改查\n（2）汽车出租：管理为出租的汽车，查（汽车status&#x3D;0），出租（填写出租类型和用户信息–&gt; 新增订单, 修改汽车状态status&#x3D;1）\n（3）订单详情：查询，订单详情，押金返还\n（4）违章处理：增（车牌号，违章信息），删，改，查\n（5）车辆保养：增（查询需要保养的车牌号），删，改，查\n（6）车辆归还：管理未归还的车辆，显示用户信息，车辆信息，订单信息，出租类型的联合查询。查询，归还\n\n\n\n\n四. 财务管理\n\n主要是 echarts 统计图，excel表导出，定期发邮件这三部分，之前已经总结了，请参考：\nvue-element-admin\n","categories":["java项目","汽车租赁管理系统"]},{"title":"算法刷题之前言","url":"/2025/04/25/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E4%B9%8B%E5%89%8D%E8%A8%80/","content":"介绍：回想自己学习算法的过程，先是大致看完了K神的《Hello算法》java版，又在leetcode中刷了大概30题，ε&#x3D;(´ο｀*)))唉，因为最近做项目把握不准时间，每天最后总是没时间刷题，写下来反思反思，每天刷两题，每天记录记录自己的刷题感受，十天为单位发一篇文章，监督自己的进度顺便总结一下K神的Hello算法部分，加油！\n","categories":["算法刷题"],"tags":["算法"]},{"title":"百日筑基之前言","url":"/2025/04/25/%E7%99%BE%E6%97%A5%E7%AD%91%E5%9F%BA%E4%B9%8B%E5%89%8D%E8%A8%80/","content":"今天我定一个百日筑基的计划，内容为戒色和锻炼，之前也尝试过，但都以失败告终，回想坚持最长的一段时间，是在戒色文章和戒色口号的熏陶下，原本我以为形式化的意义不大，但事实证明环境对一个人的影响极大，聪明的人总能把自己置于合适的环境，赋予自己驱动力和执行力，当然，这一切的前提是心中宏大的志向。所以，今天我发起百日筑基计划，每天记录自己学习戒色的知识和锻炼的感受，十天为一篇文章，分享自己的心得感悟。\n","categories":["百日筑基"]},{"title":"Linux部署java环境","url":"/2025/04/26/Linux%E9%83%A8%E7%BD%B2java%E7%8E%AF%E5%A2%83/","content":"远程连接工具FinalShell, 功能：ssh, ftp\n\n\n一. 安装配置JDK\n\n\n利用FinalShell上传文件功能上传 jdk 安装包\n\n\n解压： tar -zxvf 安装包名 -C 解压目录, 这里我的解压目录是 &#x2F;usr&#x2F;local\n\n\n配置环境变量：操作文件 &#x2F;etc&#x2F;profile，在文件末尾加上：\nJAVA_HOME=/usr/local/jdk1.8.0_171PATH=$JAVA_HOME/bin:$PATH\n\n\n\n重新加载文件，检查是否配置成功：\nsource /etc/profilejava -version\n\n\n\n\n\n二. 安装配置Tomcat\n\n\n利用FinalShell上传安装包并解压到 &#x2F;usr&#x2F;local&#x2F;\n\n\n启动tomcat\ncd /usr/local/tomcat文件父目录/binsh startup.sh\n\n\n\n查看tomcat运行进程，有两种方式：\n（1）tomcat 启动日志 catalina.out\n// 查询日志文件尾部的50行记录tail -50 /usr/local/apache-tomcat-7.0.57/logs/catalina.out\n\n（2）查看并筛选系统进程\nps -ef|grep tomcat\n\n\n\n那么现在进行启动了，就该看看防火墙了。\n// 先开启系统防火墙systemctl start firewalld// 再开放8080端口号firewall-cmd --zone=public --add-port=8080/tcp --permanent// 重新加载防火墙firewall-cmd --reload\n\n\n\n停止Tomcat，两种方式:\n（1）tomcat脚本\n// tomcat中的bin目录下：sh shutdown.sh\n\n\n\n（2）结束tomcat进程\nps -ef|grep tomcatkill -9 tomcat进程号\n\n\n\n\n\n三. 安装配置MySQL\n\n\ncentos或者RHEL系统自带mariadb数据库，这个数据库和MySQL数据库是冲突的，所以要想保证MySQL成功安装，需要卸载mariadb数据库。\n// 查看指定软件是否存在rpm -qa | grep mariadb查询当前系统中安装的名称带mariadb的软件rpm -qa | grep mysql查询当前系统中安装的名称带mysql的软件// 卸载软件// 语法: rpm -e --nodeps 软件名称rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64\n\n\n\n上传并解压, 需要自己创建mysql父目录\n\n\n按照顺序安装rpm安装包\nrpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpmyum install net-toolsrpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm\n\n\n\n启动mysql\nsystemctl status mysqld // 查看mysql服务状态systemctl start mysqld // 启动mysql服务systemctl stop mysqld // 停止mysql服务systemctl enable mysqld // 开机自启\n\n\n\n查看\nnetstat -tunlp | grep mysql // 查看mysql的服务信息ps –ef | grep mysql // 查看mysql进程\n\n\n\n登录\n初次登录查看默认生成的密码：\ncat /var/log/mysqld.log | grep password\n\n登录并修改密码：\nmysql -uroot -pset global validate_password_length=4; //设置密码长度最低位数set global validate_password_policy=LOW; //设置密码安全等级低，便于密码可以修改成rootset password = password(&#x27;root&#x27;); // 设置密码为root// 开启访问权限grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;root&#x27;;flush privileges;\n\n\n\n远程登录: 工具：Navicat\n// 防火墙开启3306端口firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload\n\n\n\n\n\n四. 安装配置Redis\n\n\n安装redis：\n\n\n下载地址：https://download.redis.io/releases/redis-6.2.6.tar.gz 稳定版， 上传安装文件\n\n\n解压，用gcc编译\n解压：tar -zxvf redis-6.2.6.tar.gz -C /opt/编译：cd /opt/redis-6.2.6/make install   // 自动安装到 /usr/local/bin下安装的文件描述：redis-benchmark：性能测试工具redis-check-aof：修复aof持久化文件redis-check-rdb：修复rdb持久化文件redis-cli：redis命令行工具redis-sentinel：redis集群哨兵使用redis-server：启动redis\n\n\n\n后台启动：\ncd /opt/redis-6.2.6cp redis.conf  redis_1.confvim redis_1.conf将daemonize的no改成yes（查找内容：/+内容 enter n）redis-server redis_1.conf\n\n\n\n启动命令行和退出redis\n命令行启动：redis-cli退出redis:(1) 先shutdown,再执行exit(2) 先exit,再杀死redis进程id\n\n\n\n\n\n五. 安装lrzsz\n\n很多的远程连接工具并没有上传下载的功能，这个时候就需要依赖于lrzsz这个软件了。\n\n\n\n所有lrzsz安装包\nyum list lrzsz\n\n\n\n在线安装lrzsz：\nyum install lrzsz.x86_64\n\n\n\n输入rz，弹出上传的窗口，选择上传的文件\n \n\n\n\n六. 项目部署\n\n（1）手动部署项目：\n\n\n\n打包，利用lrzsz的rz命令上传，运行命令： java -jar 包名 \n\n\n那我们关闭命令行，这个时候不炸了吗？🎃，我们可以后台运行项目，将日志输出到日志文件：\nnohup java -jar helloworld-1.0-SNAPSHOT.jar &amp;&gt; hello.log &amp;// nohup: 不挂起// &amp;: 让命令在后台运行\n\n\n\n停止项目：\nps -ef|grep javakill -9 进程号\n\n\n\n\n\n\n\n（2）基于shell脚本自动部署\n\n\n\n将idea中的项目代码推送到远程\n\n\n下载git, 克隆远程代码：\nyum list git // 列出git安装包yum install git // 在线安装gitgit --version  // git安装验证git clone https://gitee.com/youre-not-as-handsome-as-me/demo.git\n\n\n\n上传解压maven安装包到 &#x2F;usr&#x2F;local&#x2F;, 在&#x2F;etc&#x2F;profile文件中配置环境变量：\nvim /etc/profile修改配置文件，进入到命令模式，按G切换到最后一行，按a/i/o进入插入模式，然后在最后加入如下内容 :export MAVEN_HOME=/usr/local/apache-maven-3.5.4export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH重新加载并验证source /etc/profilemvn -v\n\n\n\n在settings.xml配置文件设置本地仓库和私服：\nvim /usr/local/apache-maven-3.5.4/conf/settings.xml&lt;localRepository&gt;/usr/local/repo&lt;/localRepository&gt;阿里私服：&lt;mirror&gt;\t&lt;id&gt;alimaven&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;aliyun maven&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;&lt;/mirror&gt;\n\n\n\n编写shell脚本bootStart.sh执行部署流程：\n#!/bin/shecho =================================echo  自动化部署脚本启动echo =================================echo 停止原来运行中的工程APP_NAME=demotpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`if [ $&#123;tpid&#125; ]; then    echo &#x27;Stop Process...&#x27;    kill -15 $tpidfisleep 2tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`if [ $&#123;tpid&#125; ]; then    echo &#x27;Kill Process!&#x27;    kill -9 $tpidelse    echo &#x27;Stop Success!&#x27;fiecho 准备从Git仓库拉取最新代码cd /usr/local/demoecho 开始从Git仓库拉取最新代码git pullecho 代码拉取完成echo 开始打包output=`mvn clean package -Dmaven.test.skip=true`cd targetecho 启动项目nohup java -jar demo-0.0.1-SNAPSHOT.jar &amp;&gt; demo.log &amp;echo 项目启动完成\n\n\n\n赋予bootStart.sh权限, 执行脚本\nchmod 777 bootStart.shsh bootStart.sh\n\n","categories":["Linux"],"tags":["Linux"]},{"title":"面试系列之redis","url":"/2025/04/28/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E4%B9%8Bredis/","content":"介绍：redis是一种无关系型数据库，在项目和面试中经常提及，正好开始系统地学redis了，今天我们就以总结的方式开始java面试之redis篇。\n\n\n\n\n一. 持久化\n\n（1）Redis AOF介绍： AOF(append only file) 是一种只记录写操作的日志，redis先执行命令再记录日志，redis不会检查日志，如果.aof日志出现问题的话，通常可以用redis-check-aof 命令进行修复。\n\n\n\nAOF三种写回策略\n在redis执行一个写命令完成后，就记录写日志，这样对redis的性能会有较大的影响，另外如果还没来得及记录记日志，系统就宕机了，会导致数据永久性丢失的问题。为了解决以上两种问题，引入了AOF三种写回策略：\n\n\nalways: 同步写回everysec: 将日志写入aof日志缓冲区，每隔一秒写入磁盘文件中no: 将日志写入aof日志缓冲区，由操作系统决定什么时候写入磁盘文件中\n\n\n\n以上三种策略 no的性能最好，但是可能大量丢失数据。 always大概率不会丢失数据，但性能较差，所以通常会这种采取everysec策略。\n\n\nAOF重写机制\n随着写操作的数量增多，占用磁盘空间增大，为节省磁盘空间，可以采用AOF重写，即读取redis现有的数据，根据数据创建写操作的日志。可以使用命令 bgrewriteaof, 可以在redis.conf中配置重写的临界条件：\nauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb\n\n\n\n了解了重写的目的之后，我们可以看看重写的流程：\nbgrewriteaof 命令进行重写，如果当前有重写正在进行就等待，如果没有，就创建一个子进程，这样就不会对主进程造成阻塞，子进程循环遍历redis内存数据到临时文件，在此期间，客户端的写请求会记录到aof缓冲区和aof重写区，确保原aof文件的完整和新的aof文件生成期间不会漏掉增添修改操作，子进程写完新的aof文件后向主进程发送请求，主进程接收请求后aof重写缓冲区的数据写入新的aof文件并且覆盖掉旧的aof文件。\n\n\n（2）Redis RDBRDB(Redis Database)是一种内存快照，记录内存某一时刻的数据状态。使用命令bgsave，即在主进程外又创建一个子进程，由这个子进程来完成RDB快照，假如内存快照有6GB的内存数据量，需要5s的时间来完成RDB文件的写入，那么在这5s内，仍旧需要将这个时间段内的添加和修改数据的操作写入到RDB文件中，这个时候就用到写时复制技术，对于增添修改操作是通过复制一个副本，子进程再执行，所以子进程是一边写快照，一遍执行主进程的操作，从而防止快照导入RDB文件时数据的丢失。\n\n\n（3）混合AOF和RDBredis.conf中打开aof，打开混合配置\nset k1 v1set k2 v2set k3 v3bgrewriteaofset k4 v4set k5 v5\n\n以上的执行结果是前三次操作后的RDB快照是aof文件的前一部分，后两个操作是aof文件的后一部分。\n如果数据不能丢失，使用AOF和RDB混合是一个好的选择。\n\n\n二. 主从复制\n\n简单点说，就是主从库采用读写分离的方式，主库进行写操作并将数据同步给从库，从库只能进行读操作。\n这样来提升读取的性能。\n\n\n主从同步原理：\n第一阶段： 从库执行 replicaof 命令，主从库建立连接，从库向主库发送psync指令，主库返回给从库唯一标识runID和复制进度offset。\n第二阶段：主库向从库发送rdb文件，从库接收并加载rdb文件\n第三阶段： 将replication buffer内的数据（即rdb文件生成之后执行的写操作）发送给从库，从库接收并加载。\n\n\n\n上面介绍了主从同步部分，那如果只有一个主库的话，从库多了，主库同步给从库的压力就会增大。这个时候就用到主从从模式了，即在主从模式的基础上，从库不在replicaof到主库，而是replicaof到其他从库，从而让从库分担数据同步的压力。\n\n\n还有一个问题，如果同步过程中网络异常，再次连接导致数据丢失怎么办？redis采用repl_backlog_buffer缓冲区记录主库写到的位置和从库读到的位置。这样再次连接时，如果从库读到的位置落后于主库写到的位置，就会从库继续读取直至与后者相同。\n缓冲空间大小&#x3D;主库写入速度 * 操作大小-主从库网络传输速度 * 操作大小\nrepl_backlog_size&#x3D;缓冲空间大小*2\n\n\n\n\n三. 哨兵模式\n\n下面是比较简单的哨兵集群的效果图：\n\n\n\n\n我们在虚拟机的centos这一个操作系统模拟哨兵集群： 用redis-server来启动不同接口的redis服务，设置一主二从的关系，在以redis-sentinel启动三个哨兵，哨兵的配置如下：\n// 端口port 26379// 监视  格式：sentinel monitor &lt;自定义的reids主节点名称&gt; &lt;IP&gt; &lt;port&gt; &lt;数量&gt;sentinel monitor mymaster 127.0.0.1 6379 1// 主节点多少毫秒未应答，则下线sentinel down-after-milliseconds mymaster 30000\n\n\n\n（1） 联系好，现在基本的服务都启动了，那么有一个问题，每个哨兵都监视主库，那哨兵是如何知道彼此的？哨兵又是如何监视从库的？\n\n是通过redis的pub&#x2F;sub发布订阅机制实现哨兵的联系，主库master有一条_sentinel__:hello的专用通道，用于哨兵之间订阅发送消息。就好像是master建了一个微信群，哨兵可以发送消息，可以看到其他哨兵的消息。\n\n哨兵向主库master发送info命令，主库将从库列表返回给哨兵，哨兵和从库建立和从库建立连接，监视从库。\n\n\n（2）运行介绍完联系之后看看如果主库宕机，哨兵集群如何判断主库宕机的？是如何选取新的主库的？\n判断主库宕机和选取新的主库的过程都设计到哨兵少数服从多数的原则，所以哨兵的数量应该是奇数更合适，主库被哨兵集群监控，多数哨兵判断主库下线了，那认为主库宕机了，这个时候要选取新的主库，那由那个哨兵来进行呢，这个时候依旧是少数服从多数，得到多数投票的那个哨兵来选取新的主库，选取新的主库有三个筛选条件，一是选取每个从库配置中优先级最大的那个，这通常意味着这个从库的配置更高，内存更大。二是选取repl_backlog_buffer缓冲区中和主库写操作的位置最接近的那个从库。三是每个redis实例都有一个id,选择id最小的。\n\n\n\n\n\n\n四. 分片集群\n\n（1）配置我们依旧在同一个虚拟主机完成，redis-server启动六个接口的redis服务, 配置文件如下：\ninclude redis.confpidfile &quot;/var/run/redis_6379.pid&quot;port 6379dbfilename &quot;dump6379.rdb&quot;# 打开集群模式cluster-enabled yes# 设定节点配置文件cluster-config-file nodes-6379.conf# 设置节点失联时间，超过，会自动进行主从切换cluster-node-timeout 15000\n\n修改redis.conf文件：\nbind 127.0.0.1 192.168.230.30(虚拟主机ip)\n\n六个服务启动\n六个服务合成一个集群：\nredis-cli --cluster create --cluster-replicas 1 192.168.230.30:6379192.168.230.30:6380 192.168.230.30:6381 192.168.230.30:6579 192.168.230.30:6580192.168.230.30:6581// --cluster create: hash slot平均分配到实例中// --cluster-replicas 1: 主从比例1:1\n\n\n\n（2）原理以及常用命令一个分片集群有16384个槽，我们向集群中存储键值对的时候，根据键值对的key, 按照CRC16算法计算出一个16bit的值，用这个值对16384取模运算，得到的数代表对应的编号的哈希槽hash slot。\n\n\nredis-cli -c -p 6379// 四大数据类型，bitmap,HyperLogLog 操作cluster nodes // 显示集群各个节点信息cluster keyslot &lt;key&gt;cluster countkeyinslot &lt;slot&gt;cluster getkeysinslot &lt;slot&gt; &lt;count&gt;\n\n\n\n因为主从比例为1:1，所以如果其中一个节点的主库宕机，从库就会接手，当如果该节点主从库全部宕机的话，默认整个集群都挂掉。默认配置：\ncluster-require-full-coverage yes\n\n如果配置为no的话，只有该节点不可存取数据，整个集群不会挂掉。\n\n\n\n\n五. Geospatial\n\n通常用于表示坐标相关数据，可以计算坐标距离呀，一个坐标范围内的其他坐标呀，可以看做是redis第六种数据结构了，基于zset有序集合，值得注意的是它的分数是由坐标计算而来。\n\n\n（1）geo原理geo是如何根据坐标计算分数的？答案便是GEOHash编码，将经纬度分别进行编码，再交叉合并，合并的值作为geo元素的权重。  \n\n\n\n经纬度编码：做N次二分区，比如经度为135，做第一次二分区，判断是位于[-180, 0)还是[0, 180], 左分区用0表示，右分区用1表示，135位于右分区，用1表示，所以最后获得了N位0或1组成的编码。\n\n交叉合并: 合并的结果第一位是经度编码的第一位，结果的第二位是纬度编码的第一位，就这样经纬度交叉进行。\n\n\n（2）geo应用\n计算两个位置的距离\ngeodist key member1 member2\n\n\n\n获取附近的geo元素\n如获取距离自己500m以内的女神姓名：\ngeoradius key 自己位置信息 500 m [ASC|DESC] [count number]\n\n可以理解为将二维位置映射到一维的线上，距离较近的两个点，实际距离也是比较近的。\n\n\n\n\n六. 事务\n\nredis事务分为原子性，一致性，隔离性和持久性。\n\n\n\n原子性：事务中所有的指令要么都执行，要么都不执行。\n可以根据错误的发生时机分为EXEC命令执行前报错，执行时发生故障，执行后报错这三种情况来讨论，在错误命令入队时，redis就会报错并记录这个错误，其他命令还能接着入队，到执行EXEC命令时，就会报错，整个事务就不能执行。如果EXEC命令执行前没报错，执行时发生故障，只有部分事务记录到AOF日志文件中，这个时候就可以使用redis-check-aof工具将未完成的事务从日志中删除，从而保证原子性。如果前两者都没问题，到了执行后报错，那这个时候大多数都是事务中执行的指令一般都和操作类型不匹配才导致报错，正确的指令能执行，错误的指令无法执行，因为redis不支持回滚，所以这个时候就无法保证原子性了。\n\n\n一致性：事务执行前后，数据库状态保持一致，符合预期的规则和约束，比如说主外键关联，完整性约束等一些数据库内部规则不能被破坏。\n执行前，入队报错，事务不执行，能确保一致性。执行时故障，一致性和数据恢复方式有关：如果只开启RDB快照，事务操作的结果没有被保存到快照中，实例重启时，数据是一致的。如果开启了RDB和AOF日志，部分操作被记录到AOF日志中，可以使用redis-check-aof清除事务中已经完成的操作保证事务的原子性，从而保证了一致性。如果EXEC命令执行后报错，正确的指令已经执行，错误的指令没有执行，可以保证一致性。\n\n\n隔离性：多个事务并行执行时，互不干扰。\n并发操作在EXEC命令执行前执行，需要通过WATCH机制进行保证，WATCH机制的作用是监视该事务操作的一个或多个键是否被其他事务修改，如果被修改，就放弃执行该事务从而保证事务的隔离性。并发操作在EXEC命令执行后执行不会破坏事务的隔离性，因为redis使用单线程执行命令，而且执行完命令，它还会保证前一个事务的所有命令执行完之后才会执行之后的事务。\n\n\n持久性：\n没有使用RDB和AOF，数据丢失\n只使用RDB快照，那么在事务执行之后，快照执行之前发生宕机，也会数据丢失，采用了RDB和AOF，AOF的三种配置选项no, everysec和always也会出现数据丢失的情况，所以事务的持久性不能保证。\n\n\n\n\nredis的事务可以保证一致性和隔离性，具备一定的原子性但不支持回滚，无法保证持久性。\n\n\n\n\n七. 缓存redis缓存属于旁路型缓存，一般有两种情况：缓存命中和缓存缺失，两种类型：只读缓存和读写缓存。\n读取数据时如果缓存命中，直接返回，如果缓存缺失，向数据库访问，并刷新缓存。向缓存写数据时，缓存将数据刷新给数据库时可以同步直写，也可以异步写回。\n\n\n（1）缓存数据的删除\n删除策略\n\n缓存数据的删除大多情况下都是过期数据的删除，redis中删除过期数据有两种策略：惰性删除和定期删除。惰性删除是数据过期了，当再次访问该数据时使用内部函数expirelfNeeded进行判断，如果过期，进行删除，节约CPU资源但内存占用大。定期删除是每隔一段时间调用函数抽取20个key进行检测，删除过期的key，如果过期的key的数量大于25%，那就循环执行，最多执行N次，这个N是可以设置的。\n\n\n\n淘汰策略\n\n那么当缓存的数据超过缓存的容量时，该如何是好？这个时候就要用到逐出算法了，制定缓存淘汰策略。\n\n\n针对过期数据的淘汰策略有四种：\nvalotile-ttl : 按照过期时间的先后顺序删除\nvalotile-random: 随机删除\nvalotile-lru: 使用LRU算法筛选过期的键值对删除\nvalotile-lfu: 使用LFU算法筛选过期的键值对删除\n\n\n针对所有数据有三种：allkeys-random   allkeys-lru   allkeys-lfu\n\n\nLRU算法是将最近不用的数据筛选出来。需要维护一个链表来管理所有的缓存数据，数据被访问时，执行链表数据的移动，利用链表的顺序筛序出N个数据，再将最小的数据淘汰。\nLFU算法是将使用频率最小的数据筛选出来。每个数据块都有一个引用计数，维护一个队列将数据块进行排序，淘汰数据时，把队列尾部的数据块删除。\n\n\n过期数据淘汰是根据具体情况选用，所有数据淘汰一般情况下用allkeys-lru策略，如果数据的使用频率相差不大，也可以用allkeys-random策略。\n\n\n（2）缓存异常\n数据不一致：\n就是数据更新，读取到的依然是旧值。通常是由两种情况导致，一种是缓存删除了，但是数据更新失败，一种是数据更新成功，但是缓存删除失败。\n解决方案：就是利用重试机制，把要删除的缓存值或者更新数据库值先存储到消息队列中，出现数据不一致，就重试。\n\n\n如果是多线程访问，分为两种情况讨论，如果是先删除缓存，后更新数据，那么一个缓存在执行到数据更新的过程中，另一个线程访问数据拿到的依然是旧值，并且还会刷新缓存，就下来的其他所有线程拿到的都是旧数据。为了避免后续的线程拿到的都是旧数据，就会用到延迟双删，这个延迟双删其实就是线程执行完删除缓存和更新数据之后，休眠一段时间，休眠结束就再次删除缓存，这样之后的其他线程访问数据时，拿到的就是新值。如果是第二种情况，先更新数据，再删除缓存，那么在线程更新数据这一时间内，其他线程拿到的是旧数据，更新并且删除缓存完成后的其他线程拿到的是新数据。\n\n\n\n\n缓存击穿\n要读取的数据在数据库中存在，在缓存中已经过期，从数据库读取的数据刷新到缓存中，这种情况叫做缓存击穿。\n\n\n那么如果大量数据同时过期，这些数据又同时被访问，那么就会对数据库造成较大压力。\n解决方案：\n对于热点数据不设置过期值，或者对于在设置过期时间的时候再加上一个随机时间，让过期时间不同，避免同时过期。至于不同时过期的情况，可以使用redis删除过期数据两种策略之一的定期删除。也可以采用预热的方式，即将热门数据提前存入缓存。还可以使用锁，缓存失效时，不是直接访问数据库，而是只有获取一个分布式锁才能访问数据库，如果不能获取分布式锁，说明已经有线程在执行，这个时候就休眠一段时间，在去获取分布式锁。\n\n\n\n\n缓存穿透\n要读取的数据在缓存中没有，在数据库中也没有。每次都会穿透到数据库，缓存成了摆设，增大数据库的压力。\n\n\n解决方案：\n可以设立缺省值，发现缓存穿透的数据就设立一个缺省值，后续访问时返回空值。\n还可以用布隆过滤器，就是数据写入数据库时，将数据的 id 存入布隆过滤器中， 读取数据时在过滤器中查找数据 id ，如果没有就不会到数据库中查询。布隆过滤器的算法就是维护一个bit类型的数组，写入数据 id ，使用三个hash函数，一个id映射到三个位置并存入1，查询 id，如果这个id映射的三个位置有0，那么id不存在。所以布隆过滤器判断id存在时，id可能存在，判断id不存在时，id就不可能存在。\n\n\n\n\n缓存雪崩\n大量请求无法在缓存中处理，全部打到数据库中致使数据库压力剧增甚至宕机。一个redis实例支持10万的QPS，而一个数据库实例一般只有1000QPS。和缓存击穿相似的一点是缓存都无效，区别于缓存击穿的一点是缓存雪崩是大量数据同时失效，缓存击穿是某个热点数据失效。有两种情况：大量数据同时过期，redis宕机\n\n\n解决方案：\n设置过期时间时再加上一个随机时间，防止大量数据同时过期。也可以进行接口限流，减小数据库压力。\n对于redis宕机引发的缓存雪崩的解决方案是：限流和服务熔断。服务熔断指的是从缓存获取数据异常就直接返回错误给前端，防止打到数据库。当然，最好的方法就是构建高可用的缓存集群，主库宕机，从库接替主库。\n\n\n\n\n八. jedis\n\nspringbot 引入 jedis 依赖包，利用 Jedis 对象来连接redis和操作redis数据。\n\n\n这里讲讲 redis 五大基本数据类型，geo的常用命令，增删改查的顺序：\n\n\n（1）redis 五大基本数据类型\nString: [set, setnx, setex, setrange, mset, msetnx]  [unlink, del] [append, incr, decr, incrby, decrby] [get, mget, getrange, substr, strlen]\nList(双向链表): [lpush, rpush, lpushx, linsert]  [lpop, rpop, lrem, brpop]  [lset]  [lrange, lindex, llen]\nHash: [hset, hsetnx, ]  [hdel]  [hincrby, hincrbyfloat]  [hget, hmget, hgetall, hexists, hkeys,hvals,hlen]\nSet: [sadd, ]  [spop, srem, smove ]  []  [amembers, sismember, scard, srandmember, sinter, sunion, sdiff, sinterstore]\nzset: [zadd]  [zrem]  [zincrby]  [zrange, zrevrange, zrangebyscore, zrevrangebyscore, zrangebylex, zcard, zcount, zrank, zscore]\n\n\n\n（2）geogeoadd &lt; key&gt; &lt; longitude&gt;&lt; latitude&gt;&lt; member&gt;\ngeopos &lt; key&gt;&lt; member&gt; [&lt; member&gt;…]\ngeodist &lt; key&gt;&lt; member1&gt;&lt; member2&gt;\ngeoradius &lt; key&gt;&lt; longitude&gt; &lt; latitue&gt; radius [m | km| fm| mi] count number\n","categories":["java面试","redis"],"tags":["redis"]},{"url":"/2025/05/04/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E4%B9%8Bmysql/","content":""},{"title":"SpringCloud-Alibaba系列之Nacos","url":"/2025/05/05/SpringCloud-Alibaba%E7%B3%BB%E5%88%97%E4%B9%8BNacos/","content":"介绍：Nacos是SpringCloud Alibaba的五大组件之一，是一个服务注册中心，主要功能为管理注册的服务，配置服务，为服务之间的访问提供DNS解析，可以设置负载均衡。\n\n\n\n\n一. 注册服务及服务之间的访问\n\n（1）服务是如何注册到Nacos从而被Nacos管理的呢？\n\n很简单，就是导入一个发现Nacos的依赖包（nacos client依赖），再通过application.yml配置文件进行注册：\n&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;\n\napplication.yml:\nserver:  port: 9002spring:  application:    name: consumer-service-nacos  # 注册到Nacos的服务名称  cloud:    nacos:      discovery:        server-addr: localhost:8848 # Nacos在本地启动的默认端口        username: nacos  # 登录Nacos的用户名和密码，用于访问验证        password: nacos        namespace: 0ffbe532-ae84-4010-ade3-591db18d33e1 # 命名空间的id        group: dev # 组\n\n\n\n\n\n（2）注册到Nacos的服务要如何访问Nacos的其他服务呢？这个时候就要用到RestTemplate对象了，我们进行一个自动配置：\n@Configurationpublic class ConfigBean &#123;    @Bean    public RestTemplate restTemplate() &#123;        return new RestTemplate();    &#125;&#125;\n\n使用restTemplate的不同方法访问其他服务，访问的地址为\nhttp://服务名\n\n\n\n这个时候有一个问题了，如果要访问的这个服务名下有多个不同的服务（端口不同），该访问拿一个呢？这个时候就要用到负载均衡了，只需在RestTemplate生成bean的方法加上 LoadBalanced 注解\n@Configurationpublic class ConfigBean &#123;    @Bean    @LoadBalanced    public RestTemplate restTemplate() &#123;        return new RestTemplate();    &#125;&#125;\n\n\n\n\n\n（3）注册服务时有那些细节需要注意呢？\n注册的是临时实例还是永久实例，有什么区别？\nspring:  cloud:    nacos:      discovery:        ephemeral: false # false为永久实例，true为临时实例，默认为临时实例\n\n\n\n区别：\n临时实例和永久实例的区别在于能否被删除，临时实例依靠心跳机制存活，默认间隔为5秒，15秒未应答就是不健康状态，30秒未应答就删除。永久实例则不会删除，实例不存在时就标记为不健康状态。\n临时实例的模式为AP(可用性和分区容错性)， 基于discro协议，只返回可以使用的数据，不一定是最新数据，强调的是数据的可用性。而永久实例的模式为CP(一致性和分区容错性)，基于raft协议实现，返回最新的数据或者错误，强调的是数据正确。\n\n\n集群\n\n如何设置负载均衡访问的权重？保护阈值是什么，如何设置？\n\n\n假如在nacos服务端中一个服务名下有多个端口，可以设置不同端口的权重，那在消费端中配置：\nspring:  cloud:    loadbalancer:      nacos:        enabled: true\n\n\n\n接上述所讲，一个服务名下有多个端口，可以设置该服务的保护阈值（0-1的浮点数），如果健康的端口数所占比例小于或等于保护阈值，那么nacos将全部实例（包括不健康的实例）返回给调用端，防止发生雪崩效应。\n\n\n\n\n二. Nacos集群\n\nNacos集群中Nacos节点的数量大于或等于3，单个Nacos使用内嵌数据库derby，Nacos集群使用MySQL（集中式处理）。\n\n\nNacos集群如何配置和启动？\n在mysql创建数据库，运行Nacos的数据表sql语句：nacos目录下&gt;conf&gt;mysql-schema.sql，这个时候集群的数据库就已经搭建好了，如果有服务要连接该集群，必须配置连接该MySQL数据库:\nspring:  datasource:    url: jdbc:mysql://localhost:3306/testcloud    username: root    password: 123456    driver-class-name: com.mysql.cj.jdbc.Driver\n\n到nacos的各个节点的application.properties配置文件中修改MySQL的数量和库名，数据库部分介绍完了，该到集群配置启动部分了，到nacos的各个节点的cluster.conf下，添加集群中所有节点的ip和端口号，最后使用startup命令启动各个节点既可。\n\n\n有一个点需要注意，在nacos2.x以后，除了启动的Http端口外，还有gRPC的通信方式，是在Http端口基础上加上偏移量，所以同一台服务器上模拟Nacos集群时，各个节点的Http端口不要相邻。\n\n\n\n\n三. Nacos配置中心\n\n设立配置中心，方便管理各个服务的配置，这个时候服务只需要连接到配置中心中指定的配置文件既可获取它自己的配置，来进行启动。\n\n\n\n在配置中心创建配置文件，各个服务是如何从配置中心里获取到它们的配置文件的？\n\n\n创建一个命名空间，或者选中命名空间，创建配置文件过程中设置组\n\n\n各个服务导入nacos-config依赖包：\n&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置文件：\nspring:  application:    name: consumer-service-nacos-config  cloud:    nacos:      config:        server-addr: localhost:8848        username: nacos        password: nacos        file-extension: yml        # namespace:        # group:   config:    import: optional:nacos:$&#123;spring.application.name&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;    # 多个配置文件的读取时，后者会覆盖前者\n\n\n\n\n\n配置中心和客户端的数据是如何同步的？\n\n\n通过长轮询的pull模式，即客户端向服务端发送获取配置的请求，服务端不会立即响应而是将请求挂起等待一段时间，如果这段时间内，配置文件发生变化，就立即响应请求，否则，就等超时之后响应请求。当客户端接受到响应请求后就再次发送长轮询请求，如此一直进行来保证配置文件的数据同步。\n\n\n","categories":["java框架","SpringCloud-Alibaba"],"tags":["SpringCloud-Alibaba","Nacos"]},{"title":"百日筑基之第一阶段","url":"/2025/05/05/%E7%99%BE%E6%97%A5%E7%AD%91%E5%9F%BA%E4%B9%8B%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/","content":"百日筑基自2025.4.25发起，今天是2025.5.5，已经过了10天，完成进度1&#x2F;10，讲讲感受吧，就是挺好的，体力精力明显地感觉有提升。体力方面一口气以寻常速度爬三楼呼吸正常，不喘气，爬五楼稍微喘气，平常快走无压力，挺胸直背比之前轻松。精力的话就最近，到了9,10天的样子吧，学习时比原先的精力更充沛了，心态慢慢回正了，有一个特别的感受，就是每天都会对明天有期盼，期待自己的百日筑基进度又向前推进了，自己的体力和精力一天比一天更强大，这种感觉很棒，好极了，哈哈，这就是百日筑基第一阶段的总结了，继续加油！\n","categories":["百日筑基"]}]